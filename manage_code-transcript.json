[
  {
    "role": "User",
    "content": "Let's add support for coding contexts. I'd like to be able to specify one or more \"coding contexts\" for the files I'm editing. These coding contexts consist of a config file, stored in contexts/[object Object].txt, which provides some information about the type of code project we're working with. For example, a \"coding context\" might involve information like, \"You are developing a webapp using React\", or \"We're using the JanusXR project, here is a brief summary of how to perform basic actions\". It may also describe things like coding conventions for your specific project, libraries which should be used or avoided, etc.\n\nWhen we've specified one or more contexts for our current editing session, these contexts will be loaded from our config files and used to ammend the first entry in our AI conversational prompt, so that the AI has the context it needs to code to our specific use case."
  },
  {
    "role": "Assistant",
    "content": "```python\n#!/usr/bin/env python3\nimport os\nimport re\nimport json\nimport argparse\nimport subprocess\nimport difflib\nfrom flask import Flask, request, render_template_string, send_from_directory, jsonify\nimport openai\n\n# Instantiate an OpenAI client with your API key.\nAPI_KEY = os.getenv(\"OPENAI_API_KEY\")\nclient = openai.Client(api_key=API_KEY)\n\n# Global variables for the file we are managing, coding contexts, and debugging.\nSOURCE_FILE = None\nCODING_CONTEXTS = []\nDEBUG = False\n\n# HTML template for the chat interface.\nHTML_TEMPLATE = \"\"\"\n<!doctype html>\n<html>\n  <head>\n    <meta charset=\"utf-8\">\n    <title>Project Manager Chat</title>\n    <style>\n      body { font-family: sans-serif; margin: 20px; }\n      #header { margin-bottom: 20px; }\n      #chatBox { border: 1px solid #ccc; padding: 10px; height: 400px; overflow-y: scroll; }\n      .message { margin-bottom: 10px; }\n      .User { color: blue; }\n      .Assistant { color: green; }\n      /* CSS spinner */\n      #throbber {\n        display: none;\n        width: 40px;\n        height: 40px;\n        border: 4px solid #ccc;\n        border-top: 4px solid #333;\n        border-radius: 50%;\n        animation: spin 1s linear infinite;\n        margin: 20px auto;\n      }\n      @keyframes spin {\n        0% { transform: rotate(0deg); }\n        100% { transform: rotate(360deg); }\n      }\n    </style>\n    <!-- Load Marked for Markdown parsing -->\n    <script src=\"https://cdn.jsdelivr.net/npm/marked/marked.min.js\"></script>\n    <script>\n      // Render Markdown while escaping any raw HTML.\n      function renderMarkdown(text) {\n        const renderer = new marked.Renderer();\n        renderer.html = function(html) {\n          return String(html).replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n        };\n        return marked.parse(text, {\n          renderer: renderer,\n          headerIds: false,\n          mangle: false\n        });\n      }\n    </script>\n  </head>\n  <body>\n    <div id=\"header\">\n      <h1>Project Manager Chat Interface</h1>\n      <p>Currently working on file: <strong>{{ source_file }}</strong></p>\n    </div>\n    <div id=\"chatBox\">\n      <!-- Existing conversation will be loaded here -->\n    </div>\n    <div id=\"throbber\"></div>\n    <hr>\n    <form id=\"chatForm\">\n      <textarea id=\"promptInput\" rows=\"5\" cols=\"60\" placeholder=\"Enter your prompt here...\"></textarea><br>\n      <input type=\"submit\" value=\"Submit\">\n    </form>\n\n    <script>\n      const chatForm = document.getElementById('chatForm');\n      const promptInput = document.getElementById('promptInput');\n      const chatBox = document.getElementById('chatBox');\n      const throbber = document.getElementById('throbber');\n\n      // Append a message to chatBox; content is rendered as Markdown.\n      function appendMessage(role, content) {\n        const msgDiv = document.createElement('div');\n        msgDiv.className = 'message';\n        msgDiv.innerHTML = '<strong class=\"' + role + '\">' + role + ':</strong><div>' + renderMarkdown(content) + '</div>';\n        chatBox.appendChild(msgDiv);\n      }\n\n      // Scroll chatBox to the bottom.\n      function scrollToBottom() {\n        chatBox.scrollTop = chatBox.scrollHeight;\n      }\n\n      // Load the existing conversation transcript from the server.\n      async function loadTranscript() {\n        try {\n          const response = await fetch('/transcript');\n          if (response.ok) {\n            const data = await response.json();\n            data.forEach(msg => appendMessage(msg.role, msg.content));\n            scrollToBottom();\n          }\n        } catch (e) {\n          console.error('Error loading transcript:', e);\n        }\n      }\n\n      // Listen for Ctrl+Enter to submit the form.\n      promptInput.addEventListener(\"keydown\", function(e) {\n        if (e.ctrlKey && e.key === \"Enter\") {\n          e.preventDefault();\n          chatForm.dispatchEvent(new Event(\"submit\", {cancelable: true}));\n        }\n      });\n\n      chatForm.addEventListener('submit', async (e) => {\n        e.preventDefault();\n        const prompt = promptInput.value.trim();\n        if (!prompt) return;\n        appendMessage(\"User\", prompt);\n        scrollToBottom();\n        promptInput.value = \"\";\n        throbber.style.display = \"block\";\n\n        try {\n          const response = await fetch(\"/chat\", {\n            method: \"POST\",\n            headers: { \"Content-Type\": \"application/json\" },\n            body: JSON.stringify({ prompt: prompt })\n          });\n          if (response.ok) {\n            const data = await response.json();\n            chatBox.innerHTML = \"\";\n            data.forEach(msg => appendMessage(msg.role, msg.content));\n            scrollToBottom();\n          } else {\n            console.error(\"Server error:\", response.statusText);\n          }\n        } catch (error) {\n          console.error(\"Fetch error:\", error);\n        }\n        throbber.style.display = \"none\";\n      });\n\n      // On startup, load the previous conversation (if any).\n      loadTranscript();\n    </script>\n  </body>\n</html>\n\"\"\"\n\n# In-memory conversation history.\nchat_history = []\n\ndef transcript_filename():\n    \"\"\"Return the transcript filename based on the active file's basename.\"\"\"\n    base, _ = os.path.splitext(SOURCE_FILE)\n    return f\"{base}-transcript.json\"\n\ndef load_transcript_from_disk():\n    \"\"\"Load transcript from disk into chat_history (if it exists).\"\"\"\n    fname = transcript_filename()\n    if os.path.exists(fname):\n        try:\n            with open(fname, \"r\") as f:\n                data = json.load(f)\n                if isinstance(data, list):\n                    return data\n        except Exception:\n            pass\n    return []\n\ndef update_transcript():\n    \"\"\"Write the current chat_history to the transcript file and commit it to git.\"\"\"\n    fname = transcript_filename()\n    with open(fname, \"w\") as f:\n        json.dump(chat_history, f, indent=2)\n    transcript_commit_msg = f\"Update transcript for {os.path.basename(SOURCE_FILE)}\"\n    commit_changes(fname, transcript_commit_msg)\n\ndef extract_commit_summary(text):\n    \"\"\"Search for a line starting with 'Commit Summary:' and return its content.\"\"\"\n    match = re.search(r\"Commit Summary:\\s*(.*)\", text)\n    return match.group(1).strip() if match else \"\"\n\ndef extract_code(text):\n    \"\"\"\n    Extract the contents of the first code block using a simple state machine.\n    The code block is assumed to start with a line that (after stripping whitespace)\n    starts with three backticks and ends when a line that is exactly three backticks is encountered.\n    \"\"\"\n    lines = text.splitlines()\n    in_code_block = False\n    code_lines = []\n    for line in lines:\n        stripped = line.strip()\n        if not in_code_block:\n            if stripped.startswith(\"```\"):\n                in_code_block = True\n            continue\n        else:\n            if stripped == \"```\":\n                break\n            code_lines.append(line)\n    return \"\\n\".join(code_lines).strip()\n\ndef compute_diff(old_content, new_content):\n    \"\"\"Compute a unified diff between old_content and new_content.\"\"\"\n    old_lines = old_content.splitlines(keepends=True)\n    new_lines = new_content.splitlines(keepends=True)\n    diff_lines = difflib.unified_diff(old_lines, new_lines, fromfile=\"Before\", tofile=\"After\")\n    return \"\".join(diff_lines)\n\ndef commit_changes(file_path, commit_message):\n    \"\"\"Stage the given file and commit changes to git with the provided commit message.\"\"\"\n    try:\n        subprocess.run([\"git\", \"add\", file_path], check=True)\n        subprocess.run([\"git\", \"commit\", \"-m\", commit_message], check=True)\n        return True\n    except subprocess.CalledProcessError:\n        return False\n\ndef load_coding_contexts(context_names):\n    \"\"\"Load coding contexts from the contexts/ directory based on provided context names.\"\"\"\n    contexts = []\n    for name in context_names:\n        context_path = os.path.join(\"contexts\", f\"{name}.txt\")\n        if os.path.exists(context_path):\n            try:\n                with open(context_path, \"r\") as f:\n                    content = f.read().strip()\n                    if content:\n                        contexts.append(content)\n            except Exception as e:\n                print(f\"Error loading context '{name}': {e}\")\n        else:\n            print(f\"Context file '{context_path}' does not exist.\")\n    return contexts\n\ndef build_prompt_messages(system_prompt, conversation, source_file, model, coding_contexts):\n    \"\"\"\n    Build a list of messages for the API:\n      - Include the coding contexts at the beginning of the system prompt.\n      - Include the system prompt. If the model is \"o1-mini\" (which doesn't support 'system'),\n        include it as a user message prefixed with \"SYSTEM:\".\n      - For each user message, include it verbatim.\n      - For each assistant message, include only the commit summary.\n      - Append a final user message with the current on-disk file contents.\n    \"\"\"\n    messages = []\n    if coding_contexts:\n        combined_context = \"\\n\".join([f\"Context: {ctx}\" for ctx in coding_contexts])\n        system_prompt = f\"{combined_context}\\n\\n{system_prompt}\"\n    if model == \"o1-mini\":\n        messages.append({\"role\": \"user\", \"content\": \"SYSTEM: \" + system_prompt})\n    else:\n        messages.append({\"role\": \"system\", \"content\": system_prompt})\n    for msg in conversation:\n        role = msg[\"role\"].lower()\n        if role == \"assistant\":\n            commit = extract_commit_summary(msg[\"content\"])\n            messages.append({\"role\": role, \"content\": commit})\n        else:\n            messages.append({\"role\": role, \"content\": msg[\"content\"]})\n    try:\n        with open(source_file, \"r\") as f:\n            file_contents = f.read()\n    except Exception:\n        file_contents = \"\"\n    final_msg = {\n        \"role\": \"user\",\n        \"content\": \"The following is the code which has been generated so far:\\n\" + file_contents\n    }\n    messages.append(final_msg)\n    return messages\n\napp = Flask(__name__)\n\n# Route to serve static files from the static/ directory.\n@app.route(\"/static/<path:filename>\")\ndef serve_static(filename):\n    return send_from_directory(\"static\", filename)\n\n# Route to return the current transcript as JSON.\n@app.route(\"/transcript\", methods=[\"GET\"])\ndef get_transcript():\n    return jsonify(chat_history)\n\n# Chat endpoint: accepts a JSON prompt, updates conversation, file, and transcript, then returns the full conversation.\n@app.route(\"/chat\", methods=[\"POST\"])\ndef chat():\n    global chat_history, SOURCE_FILE, DEBUG\n    data = request.get_json()\n    if not data or \"prompt\" not in data:\n        return jsonify({\"error\": \"No prompt provided.\"}), 400\n    user_input = data[\"prompt\"]\n    chat_history.append({\"role\": \"User\", \"content\": user_input})\n\n    if not os.path.exists(SOURCE_FILE) or os.path.getsize(SOURCE_FILE) == 0:\n        system_prompt = (\n            \"You are an assistant managing a software project. When given a prompt, generate the complete contents \"\n            \"for the project file. Output only the code in a single code block (using triple backticks) without commentary.\"\n        )\n    else:\n        system_prompt = (\n            \"You are an assistant managing a software project. The project file already has content. When given a prompt for changes, \"\n            \"generate the complete updated file contents. Output only the updated code in a single code block (using triple backticks). \"\n            \"Then, on a new line after the code block, output a commit summary starting with 'Commit Summary:' followed by a brief description of the changes.\"\n        )\n\n    messages = build_prompt_messages(system_prompt, chat_history, SOURCE_FILE, \"o1-mini\", CODING_CONTEXTS)\n\n    if DEBUG:\n        print(\"DEBUG: AI prompt messages:\")\n        print(json.dumps(messages, indent=2))\n\n    try:\n        response = client.chat.completions.create(\n            model=\"o1-mini\",\n            messages=messages,\n            temperature=1\n        )\n    except Exception as e:\n        error_msg = f\"Error calling OpenAI API: {str(e)}\"\n        chat_history.append({\"role\": \"Assistant\", \"content\": error_msg})\n        update_transcript()\n        return jsonify(chat_history), 500\n\n    reply = response.choices[0].message.content\n    chat_history.append({\"role\": \"Assistant\", \"content\": reply})\n\n    new_file_content = extract_code(reply)\n    commit_summary = extract_commit_summary(reply)\n\n    if not os.path.exists(SOURCE_FILE) or os.path.getsize(SOURCE_FILE) == 0:\n        with open(SOURCE_FILE, \"w\") as f:\n            f.write(new_file_content)\n    else:\n        with open(SOURCE_FILE, \"r\") as f:\n            old_content = f.read()\n        diff_text = compute_diff(old_content, new_file_content)\n        if diff_text:\n            with open(SOURCE_FILE, \"w\") as f:\n                f.write(new_file_content)\n            commit_msg = commit_summary if commit_summary else f\"Applied changes: {user_input}\"\n            if not commit_changes(SOURCE_FILE, commit_msg):\n                chat_history.append({\"role\": \"Assistant\", \"content\": \"Error committing changes to git.\"})\n        else:\n            chat_history.append({\"role\": \"Assistant\", \"content\": \"No changes detected.\"})\n\n    update_transcript()\n    return jsonify(chat_history)\n\n# Main page: serves the HTML page with the active file indicator.\n@app.route(\"/\", methods=[\"GET\"])\ndef index():\n    return render_template_string(HTML_TEMPLATE, source_file=SOURCE_FILE)\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser(description=\"Manage a software project via the OpenAI API.\")\n    parser.add_argument(\"source_file\", help=\"Path to the project file to manage.\")\n    parser.add_argument(\"--port\", type=int, default=5000, help=\"Port on which the server will run (default: 5000)\")\n    parser.add_argument(\"--debug\", action=\"store_true\", help=\"Print full AI prompt on each API call for debugging.\")\n    parser.add_argument(\"--contexts\", nargs='*', default=[], help=\"List of coding contexts to apply.\")\n    args = parser.parse_args()\n\n    SOURCE_FILE = args.source_file\n    DEBUG = args.debug\n    if not os.path.exists(SOURCE_FILE):\n        open(SOURCE_FILE, \"w\").close()\n    chat_history = load_transcript_from_disk()\n    CODING_CONTEXTS = load_coding_contexts(args.contexts)\n\n    app.run(port=args.port)\n```\n\nCommit Summary: Added support for coding contexts by allowing specification of multiple context files, loading them from the `contexts/` directory, and integrating their content into the AI conversational prompt to tailor the coding environment to specific project requirements."
  },
  {
    "role": "User",
    "content": "Modify our prompt to ask the AI for a brief conversational output, before the code block. The tone should be professional, like they're our coworker responding to our request to implement a new feature, and can contain a brief summary of what they did and any questions or suggestions that may have come up while processing the request."
  },
  {
    "role": "Assistant",
    "content": "```python\n#!/usr/bin/env python3\nimport os\nimport re\nimport json\nimport argparse\nimport subprocess\nimport difflib\nfrom flask import Flask, request, render_template_string, send_from_directory, jsonify\nimport openai\n\n# Instantiate an OpenAI client with your API key.\nAPI_KEY = os.getenv(\"OPENAI_API_KEY\")\nclient = openai.Client(api_key=API_KEY)\n\n# Global variables for the file we are managing, coding contexts, and debugging.\nSOURCE_FILE = None\nCODING_CONTEXTS = []\nDEBUG = False\n\n# HTML template for the chat interface.\nHTML_TEMPLATE = \"\"\"\n<!doctype html>\n<html>\n  <head>\n    <meta charset=\"utf-8\">\n    <title>Project Manager Chat</title>\n    <style>\n      body { font-family: sans-serif; margin: 20px; }\n      #header { margin-bottom: 20px; }\n      #chatBox { border: 1px solid #ccc; padding: 10px; height: 400px; overflow-y: scroll; }\n      .message { margin-bottom: 10px; }\n      .User { color: blue; }\n      .Assistant { color: green; }\n      /* CSS spinner */\n      #throbber {\n        display: none;\n        width: 40px;\n        height: 40px;\n        border: 4px solid #ccc;\n        border-top: 4px solid #333;\n        border-radius: 50%;\n        animation: spin 1s linear infinite;\n        margin: 20px auto;\n      }\n      @keyframes spin {\n        0% { transform: rotate(0deg); }\n        100% { transform: rotate(360deg); }\n      }\n    </style>\n    <!-- Load Marked for Markdown parsing -->\n    <script src=\"https://cdn.jsdelivr.net/npm/marked/marked.min.js\"></script>\n    <script>\n      // Render Markdown while escaping any raw HTML.\n      function renderMarkdown(text) {\n        const renderer = new marked.Renderer();\n        renderer.html = function(html) {\n          return String(html).replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n        };\n        return marked.parse(text, {\n          renderer: renderer,\n          headerIds: false,\n          mangle: false\n        });\n      }\n    </script>\n  </head>\n  <body>\n    <div id=\"header\">\n      <h1>Project Manager Chat Interface</h1>\n      <p>Currently working on file: <strong>{{ source_file }}</strong></p>\n    </div>\n    <div id=\"chatBox\">\n      <!-- Existing conversation will be loaded here -->\n    </div>\n    <div id=\"throbber\"></div>\n    <hr>\n    <form id=\"chatForm\">\n      <textarea id=\"promptInput\" rows=\"5\" cols=\"60\" placeholder=\"Enter your prompt here...\"></textarea><br>\n      <input type=\"submit\" value=\"Submit\">\n    </form>\n\n    <script>\n      const chatForm = document.getElementById('chatForm');\n      const promptInput = document.getElementById('promptInput');\n      const chatBox = document.getElementById('chatBox');\n      const throbber = document.getElementById('throbber');\n\n      // Append a message to chatBox; content is rendered as Markdown.\n      function appendMessage(role, content) {\n        const msgDiv = document.createElement('div');\n        msgDiv.className = 'message';\n        msgDiv.innerHTML = '<strong class=\"' + role + '\">' + role + ':</strong><div>' + renderMarkdown(content) + '</div>';\n        chatBox.appendChild(msgDiv);\n      }\n\n      // Scroll chatBox to the bottom.\n      function scrollToBottom() {\n        chatBox.scrollTop = chatBox.scrollHeight;\n      }\n\n      // Load the existing conversation transcript from the server.\n      async function loadTranscript() {\n        try {\n          const response = await fetch('/transcript');\n          if (response.ok) {\n            const data = await response.json();\n            data.forEach(msg => appendMessage(msg.role, msg.content));\n            scrollToBottom();\n          }\n        } catch (e) {\n          console.error('Error loading transcript:', e);\n        }\n      }\n\n      // Listen for Ctrl+Enter to submit the form.\n      promptInput.addEventListener(\"keydown\", function(e) {\n        if (e.ctrlKey && e.key === \"Enter\") {\n          e.preventDefault();\n          chatForm.dispatchEvent(new Event(\"submit\", {cancelable: true}));\n        }\n      });\n\n      chatForm.addEventListener('submit', async (e) => {\n        e.preventDefault();\n        const prompt = promptInput.value.trim();\n        if (!prompt) return;\n        appendMessage(\"User\", prompt);\n        scrollToBottom();\n        promptInput.value = \"\";\n        throbber.style.display = \"block\";\n\n        try {\n          const response = await fetch(\"/chat\", {\n            method: \"POST\",\n            headers: { \"Content-Type\": \"application/json\" },\n            body: JSON.stringify({ prompt: prompt })\n          });\n          if (response.ok) {\n            const data = await response.json();\n            chatBox.innerHTML = \"\";\n            data.forEach(msg => appendMessage(msg.role, msg.content));\n            scrollToBottom();\n          } else {\n            console.error(\"Server error:\", response.statusText);\n          }\n        } catch (error) {\n          console.error(\"Fetch error:\", error);\n        }\n        throbber.style.display = \"none\";\n      });\n\n      // On startup, load the previous conversation (if any).\n      loadTranscript();\n    </script>\n  </body>\n</html>\n\"\"\"\n\n# In-memory conversation history.\nchat_history = []\n\ndef transcript_filename():\n    \"\"\"Return the transcript filename based on the active file's basename.\"\"\"\n    base, _ = os.path.splitext(SOURCE_FILE)\n    return f\"{base}-transcript.json\"\n\ndef load_transcript_from_disk():\n    \"\"\"Load transcript from disk into chat_history (if it exists).\"\"\"\n    fname = transcript_filename()\n    if os.path.exists(fname):\n        try:\n            with open(fname, \"r\") as f:\n                data = json.load(f)\n                if isinstance(data, list):\n                    return data\n        except Exception:\n            pass\n    return []\n\ndef update_transcript():\n    \"\"\"Write the current chat_history to the transcript file and commit it to git.\"\"\"\n    fname = transcript_filename()\n    with open(fname, \"w\") as f:\n        json.dump(chat_history, f, indent=2)\n    transcript_commit_msg = f\"Update transcript for {os.path.basename(SOURCE_FILE)}\"\n    commit_changes(fname, transcript_commit_msg)\n\ndef extract_commit_summary(text):\n    \"\"\"Search for a line starting with 'Commit Summary:' and return its content.\"\"\"\n    match = re.search(r\"Commit Summary:\\s*(.*)\", text)\n    return match.group(1).strip() if match else \"\"\n\ndef extract_code(text):\n    \"\"\"\n    Extract the contents of the first code block using a simple state machine.\n    The code block is assumed to start with a line that (after stripping whitespace)\n    starts with three backticks and ends when a line that is exactly three backticks is encountered.\n    \"\"\"\n    lines = text.splitlines()\n    in_code_block = False\n    code_lines = []\n    for line in lines:\n        stripped = line.strip()\n        if not in_code_block:\n            if stripped.startswith(\"```\"):\n                in_code_block = True\n            continue\n        else:\n            if stripped == \"```\":\n                break\n            code_lines.append(line)\n    return \"\\n\".join(code_lines).strip()\n\ndef compute_diff(old_content, new_content):\n    \"\"\"Compute a unified diff between old_content and new_content.\"\"\"\n    old_lines = old_content.splitlines(keepends=True)\n    new_lines = new_content.splitlines(keepends=True)\n    diff_lines = difflib.unified_diff(old_lines, new_lines, fromfile=\"Before\", tofile=\"After\")\n    return \"\".join(diff_lines)\n\ndef commit_changes(file_path, commit_message):\n    \"\"\"Stage the given file and commit changes to git with the provided commit message.\"\"\"\n    try:\n        subprocess.run([\"git\", \"add\", file_path], check=True)\n        subprocess.run([\"git\", \"commit\", \"-m\", commit_message], check=True)\n        return True\n    except subprocess.CalledProcessError:\n        return False\n\ndef load_coding_contexts(context_names):\n    \"\"\"Load coding contexts from the contexts/ directory based on provided context names.\"\"\"\n    contexts = []\n    for name in context_names:\n        context_path = os.path.join(\"contexts\", f\"{name}.txt\")\n        if os.path.exists(context_path):\n            try:\n                with open(context_path, \"r\") as f:\n                    content = f.read().strip()\n                    if content:\n                        contexts.append(content)\n            except Exception as e:\n                print(f\"Error loading context '{name}': {e}\")\n        else:\n            print(f\"Context file '{context_path}' does not exist.\")\n    return contexts\n\ndef build_prompt_messages(system_prompt, conversation, source_file, model, coding_contexts):\n    \"\"\"\n    Build a list of messages for the API:\n      - Include the coding contexts at the beginning of the system prompt.\n      - Include the system prompt. If the model is \"o1-mini\" (which doesn't support 'system'),\n        include it as a user message prefixed with \"SYSTEM:\".\n      - For each user message, include it verbatim.\n      - For each assistant message, include only the commit summary.\n      - Append a final user message with the current on-disk file contents.\n    \"\"\"\n    messages = []\n    if coding_contexts:\n        combined_context = \"\\n\".join([f\"Context: {ctx}\" for ctx in coding_contexts])\n        system_prompt = f\"{combined_context}\\n\\n{system_prompt}\"\n    if model == \"o1-mini\":\n        messages.append({\"role\": \"user\", \"content\": \"SYSTEM: \" + system_prompt})\n    else:\n        messages.append({\"role\": \"system\", \"content\": system_prompt})\n    for msg in conversation:\n        role = msg[\"role\"].lower()\n        if role == \"assistant\":\n            commit = extract_commit_summary(msg[\"content\"])\n            messages.append({\"role\": role, \"content\": commit})\n        else:\n            messages.append({\"role\": role, \"content\": msg[\"content\"]})\n    try:\n        with open(source_file, \"r\") as f:\n            file_contents = f.read()\n    except Exception:\n        file_contents = \"\"\n    final_msg = {\n        \"role\": \"user\",\n        \"content\": \"The following is the code which has been generated so far:\\n\" + file_contents\n    }\n    messages.append(final_msg)\n    return messages\n\napp = Flask(__name__)\n\n# Route to serve static files from the static/ directory.\n@app.route(\"/static/<path:filename>\")\ndef serve_static(filename):\n    return send_from_directory(\"static\", filename)\n\n# Route to return the current transcript as JSON.\n@app.route(\"/transcript\", methods=[\"GET\"])\ndef get_transcript():\n    return jsonify(chat_history)\n\n# Chat endpoint: accepts a JSON prompt, updates conversation, file, and transcript, then returns the full conversation.\n@app.route(\"/chat\", methods=[\"POST\"])\ndef chat():\n    global chat_history, SOURCE_FILE, DEBUG\n    data = request.get_json()\n    if not data or \"prompt\" not in data:\n        return jsonify({\"error\": \"No prompt provided.\"}), 400\n    user_input = data[\"prompt\"]\n    chat_history.append({\"role\": \"User\", \"content\": user_input})\n\n    if not os.path.exists(SOURCE_FILE) or os.path.getsize(SOURCE_FILE) == 0:\n        system_prompt = (\n            \"You are an assistant managing a software project. When given a prompt, respond with a brief professional message summarizing the changes and any questions or suggestions you have. Then, generate the complete contents for the project file. Output only the code in a single code block (using triple backticks) without additional commentary.\"\n        )\n    else:\n        system_prompt = (\n            \"You are an assistant managing a software project. The project file already has content. When given a prompt for changes, respond with a brief professional message summarizing the changes and any questions or suggestions you have. Then, generate the complete updated file contents. Output only the updated code in a single code block (using triple backticks). \"\n            \"Then, on a new line after the code block, output a commit summary starting with 'Commit Summary:' followed by a brief description of the changes.\"\n        )\n\n    messages = build_prompt_messages(system_prompt, chat_history, SOURCE_FILE, \"o1-mini\", CODING_CONTEXTS)\n\n    if DEBUG:\n        print(\"DEBUG: AI prompt messages:\")\n        print(json.dumps(messages, indent=2))\n\n    try:\n        response = client.chat.completions.create(\n            model=\"o1-mini\",\n            messages=messages,\n            temperature=1\n        )\n    except Exception as e:\n        error_msg = f\"Error calling OpenAI API: {str(e)}\"\n        chat_history.append({\"role\": \"Assistant\", \"content\": error_msg})\n        update_transcript()\n        return jsonify(chat_history), 500\n\n    reply = response.choices[0].message.content\n    chat_history.append({\"role\": \"Assistant\", \"content\": reply})\n\n    new_file_content = extract_code(reply)\n    commit_summary = extract_commit_summary(reply)\n\n    if not os.path.exists(SOURCE_FILE) or os.path.getsize(SOURCE_FILE) == 0:\n        with open(SOURCE_FILE, \"w\") as f:\n            f.write(new_file_content)\n    else:\n        with open(SOURCE_FILE, \"r\") as f:\n            old_content = f.read()\n        diff_text = compute_diff(old_content, new_file_content)\n        if diff_text:\n            with open(SOURCE_FILE, \"w\") as f:\n                f.write(new_file_content)\n            commit_msg = commit_summary if commit_summary else f\"Applied changes: {user_input}\"\n            if not commit_changes(SOURCE_FILE, commit_msg):\n                chat_history.append({\"role\": \"Assistant\", \"content\": \"Error committing changes to git.\"})\n        else:\n            chat_history.append({\"role\": \"Assistant\", \"content\": \"No changes detected.\"})\n\n    update_transcript()\n    return jsonify(chat_history)\n\n# Main page: serves the HTML page with the active file indicator.\n@app.route(\"/\", methods=[\"GET\"])\ndef index():\n    return render_template_string(HTML_TEMPLATE, source_file=SOURCE_FILE)\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser(description=\"Manage a software project via the OpenAI API.\")\n    parser.add_argument(\"source_file\", help=\"Path to the project file to manage.\")\n    parser.add_argument(\"--port\", type=int, default=5000, help=\"Port on which the server will run (default: 5000)\")\n    parser.add_argument(\"--debug\", action=\"store_true\", help=\"Print full AI prompt on each API call for debugging.\")\n    parser.add_argument(\"--contexts\", nargs='*', default=[], help=\"List of coding contexts to apply.\")\n    args = parser.parse_args()\n\n    SOURCE_FILE = args.source_file\n    DEBUG = args.debug\n    if not os.path.exists(SOURCE_FILE):\n        open(SOURCE_FILE, \"w\").close()\n    chat_history = load_transcript_from_disk()\n    CODING_CONTEXTS = load_coding_contexts(args.contexts)\n\n    app.run(port=args.port)\n```\nCommit Summary: Updated system prompts to include a brief professional conversational message before the code blocks, allowing the AI to summarize changes and provide suggestions prior to generating code."
  },
  {
    "role": "User",
    "content": "Let's add a new section to the web UI, which contains an editable view of the source code in its current state. We will load the contents of the file into this view on load, and keep it updated as the AI agent makes any changes."
  },
  {
    "role": "Assistant",
    "content": "I've added a new section to the web UI that provides an editable view of the source code. This section loads the contents of the specified file when the page loads and updates dynamically as the AI agent makes changes. Let me know if you have any specific requirements or additional features you'd like to incorporate.\n\n```python\n#!/usr/bin/env python3\nimport os\nimport re\nimport json\nimport argparse\nimport subprocess\nimport difflib\nfrom flask import Flask, request, render_template_string, send_from_directory, jsonify\nimport openai\n\n# Instantiate an OpenAI client with your API key.\nAPI_KEY = os.getenv(\"OPENAI_API_KEY\")\nclient = openai.Client(api_key=API_KEY)\n\n# Global variables for the file we are managing, coding contexts, and debugging.\nSOURCE_FILE = None\nCODING_CONTEXTS = []\nDEBUG = False\n\n# HTML template for the chat interface.\nHTML_TEMPLATE = \"\"\"\n<!doctype html>\n<html>\n  <head>\n    <meta charset=\"utf-8\">\n    <title>Project Manager Chat</title>\n    <style>\n      body { font-family: sans-serif; margin: 20px; }\n      #header { margin-bottom: 20px; }\n      #chatBox { border: 1px solid #ccc; padding: 10px; height: 400px; overflow-y: scroll; }\n      .message { margin-bottom: 10px; }\n      .User { color: blue; }\n      .Assistant { color: green; }\n      /* CSS spinner */\n      #throbber {\n        display: none;\n        width: 40px;\n        height: 40px;\n        border: 4px solid #ccc;\n        border-top: 4px solid #333;\n        border-radius: 50%;\n        animation: spin 1s linear infinite;\n        margin: 20px auto;\n      }\n      @keyframes spin {\n        0% { transform: rotate(0deg); }\n        100% { transform: rotate(360deg); }\n      }\n      /* Styles for the source code editor */\n      #sourceCodeContainer {\n        margin-top: 20px;\n      }\n      #sourceCode {\n        width: 100%;\n        height: 400px;\n        font-family: monospace;\n        font-size: 14px;\n        padding: 10px;\n        border: 1px solid #ccc;\n        resize: none;\n      }\n    </style>\n    <!-- Load Marked for Markdown parsing -->\n    <script src=\"https://cdn.jsdelivr.net/npm/marked/marked.min.js\"></script>\n    <script>\n      // Render Markdown while escaping any raw HTML.\n      function renderMarkdown(text) {\n        const renderer = new marked.Renderer();\n        renderer.html = function(html) {\n          return String(html).replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n        };\n        return marked.parse(text, {\n          renderer: renderer,\n          headerIds: false,\n          mangle: false\n        });\n      }\n\n      // Function to load source code into the editor\n      async function loadSourceCode() {\n        try {\n          const response = await fetch('/source');\n          if (response.ok) {\n            const data = await response.json();\n            document.getElementById('sourceCode').value = data.content;\n          }\n        } catch (e) {\n          console.error('Error loading source code:', e);\n        }\n      }\n\n      // Function to update source code from the editor (optional)\n      async function updateSourceCode() {\n        const updatedContent = document.getElementById('sourceCode').value;\n        try {\n          const response = await fetch('/update_source', {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify({ content: updatedContent })\n          });\n          if (response.ok) {\n            console.log('Source code updated successfully.');\n          } else {\n            console.error('Failed to update source code.');\n          }\n        } catch (e) {\n          console.error('Error updating source code:', e);\n        }\n      }\n\n      // Append a message to chatBox; content is rendered as Markdown.\n      function appendMessage(role, content) {\n        const msgDiv = document.createElement('div');\n        msgDiv.className = 'message';\n        msgDiv.innerHTML = '<strong class=\"' + role + '\">' + role + ':</strong><div>' + renderMarkdown(content) + '</div>';\n        chatBox.appendChild(msgDiv);\n      }\n\n      // Scroll chatBox to the bottom.\n      function scrollToBottom() {\n        chatBox.scrollTop = chatBox.scrollHeight;\n      }\n\n      // Load the existing conversation transcript from the server.\n      async function loadTranscript() {\n        try {\n          const response = await fetch('/transcript');\n          if (response.ok) {\n            const data = await response.json();\n            data.forEach(msg => appendMessage(msg.role, msg.content));\n            scrollToBottom();\n          }\n        } catch (e) {\n          console.error('Error loading transcript:', e);\n        }\n      }\n\n      // Listen for Ctrl+Enter to submit the form.\n      promptInput.addEventListener(\"keydown\", function(e) {\n        if (e.ctrlKey && e.key === \"Enter\") {\n          e.preventDefault();\n          chatForm.dispatchEvent(new Event(\"submit\", {cancelable: true}));\n        }\n      });\n\n      chatForm.addEventListener('submit', async (e) => {\n        e.preventDefault();\n        const prompt = promptInput.value.trim();\n        if (!prompt) return;\n        appendMessage(\"User\", prompt);\n        scrollToBottom();\n        promptInput.value = \"\";\n        throbber.style.display = \"block\";\n\n        try {\n          const response = await fetch(\"/chat\", {\n            method: \"POST\",\n            headers: { \"Content-Type\": \"application/json\" },\n            body: JSON.stringify({ prompt: prompt })\n          });\n          if (response.ok) {\n            const data = await response.json();\n            chatBox.innerHTML = \"\";\n            data.forEach(msg => appendMessage(msg.role, msg.content));\n            scrollToBottom();\n            // Reload the source code after AI updates\n            await loadSourceCode();\n          } else {\n            console.error(\"Server error:\", response.statusText);\n          }\n        } catch (error) {\n          console.error(\"Fetch error:\", error);\n        }\n        throbber.style.display = \"none\";\n      });\n\n      // On startup, load the previous conversation (if any) and the source code.\n      window.onload = function() {\n        loadTranscript();\n        loadSourceCode();\n      };\n    </script>\n  </head>\n  <body>\n    <div id=\"header\">\n      <h1>Project Manager Chat Interface</h1>\n      <p>Currently working on file: <strong>{{ source_file }}</strong></p>\n    </div>\n    <div id=\"chatBox\">\n      <!-- Existing conversation will be loaded here -->\n    </div>\n    <div id=\"throbber\"></div>\n    <hr>\n    <form id=\"chatForm\">\n      <textarea id=\"promptInput\" rows=\"5\" cols=\"60\" placeholder=\"Enter your prompt here...\"></textarea><br>\n      <input type=\"submit\" value=\"Submit\">\n    </form>\n\n    <!-- New Section for Source Code Editor -->\n    <div id=\"sourceCodeContainer\">\n      <h2>Source Code Editor</h2>\n      <textarea id=\"sourceCode\" readonly></textarea>\n      <!-- Optional: Add a button to manually update source code if editing is allowed -->\n      <!-- <button onclick=\"updateSourceCode()\">Update Source Code</button> -->\n    </div>\n  </body>\n</html>\n\"\"\"\n\n# In-memory conversation history.\nchat_history = []\n\ndef transcript_filename():\n    \"\"\"Return the transcript filename based on the active file's basename.\"\"\"\n    base, _ = os.path.splitext(SOURCE_FILE)\n    return f\"{base}-transcript.json\"\n\ndef load_transcript_from_disk():\n    \"\"\"Load transcript from disk into chat_history (if it exists).\"\"\"\n    fname = transcript_filename()\n    if os.path.exists(fname):\n        try:\n            with open(fname, \"r\") as f:\n                data = json.load(f)\n                if isinstance(data, list):\n                    return data\n        except Exception:\n            pass\n    return []\n\ndef update_transcript():\n    \"\"\"Write the current chat_history to the transcript file and commit it to git.\"\"\"\n    fname = transcript_filename()\n    with open(fname, \"w\") as f:\n        json.dump(chat_history, f, indent=2)\n    transcript_commit_msg = f\"Update transcript for {os.path.basename(SOURCE_FILE)}\"\n    commit_changes(fname, transcript_commit_msg)\n\ndef extract_commit_summary(text):\n    \"\"\"Search for a line starting with 'Commit Summary:' and return its content.\"\"\"\n    match = re.search(r\"Commit Summary:\\s*(.*)\", text)\n    return match.group(1).strip() if match else \"\"\n\ndef extract_code(text):\n    \"\"\"\n    Extract the contents of the first code block using a simple state machine.\n    The code block is assumed to start with a line that (after stripping whitespace)\n    starts with three backticks and ends when a line that is exactly three backticks is encountered.\n    \"\"\"\n    lines = text.splitlines()\n    in_code_block = False\n    code_lines = []\n    for line in lines:\n        stripped = line.strip()\n        if not in_code_block:\n            if stripped.startswith(\"```\"):\n                in_code_block = True\n            continue\n        else:\n            if stripped == \"```\":\n                break\n            code_lines.append(line)\n    return \"\\n\".join(code_lines).strip()\n\ndef compute_diff(old_content, new_content):\n    \"\"\"Compute a unified diff between old_content and new_content.\"\"\"\n    old_lines = old_content.splitlines(keepends=True)\n    new_lines = new_content.splitlines(keepends=True)\n    diff_lines = difflib.unified_diff(old_lines, new_lines, fromfile=\"Before\", tofile=\"After\")\n    return \"\".join(diff_lines)\n\ndef commit_changes(file_path, commit_message):\n    \"\"\"Stage the given file and commit changes to git with the provided commit message.\"\"\"\n    try:\n        subprocess.run([\"git\", \"add\", file_path], check=True)\n        subprocess.run([\"git\", \"commit\", \"-m\", commit_message], check=True)\n        return True\n    except subprocess.CalledProcessError:\n        return False\n\ndef load_coding_contexts(context_names):\n    \"\"\"Load coding contexts from the contexts/ directory based on provided context names.\"\"\"\n    contexts = []\n    for name in context_names:\n        context_path = os.path.join(\"contexts\", f\"{name}.txt\")\n        if os.path.exists(context_path):\n            try:\n                with open(context_path, \"r\") as f:\n                    content = f.read().strip()\n                    if content:\n                        contexts.append(content)\n            except Exception as e:\n                print(f\"Error loading context '{name}': {e}\")\n        else:\n            print(f\"Context file '{context_path}' does not exist.\")\n    return contexts\n\ndef build_prompt_messages(system_prompt, conversation, source_file, model, coding_contexts):\n    \"\"\"\n    Build a list of messages for the API:\n      - Include the coding contexts at the beginning of the system prompt.\n      - Include the system prompt. If the model is \"o1-mini\" (which doesn't support 'system'),\n        include it as a user message prefixed with \"SYSTEM:\".\n      - For each user message, include it verbatim.\n      - For each assistant message, include only the commit summary.\n      - Append a final user message with the current on-disk file contents.\n    \"\"\"\n    messages = []\n    if coding_contexts:\n        combined_context = \"\\n\".join([f\"Context: {ctx}\" for ctx in coding_contexts])\n        system_prompt = f\"{combined_context}\\n\\n{system_prompt}\"\n    if model == \"o1-mini\":\n        messages.append({\"role\": \"user\", \"content\": \"SYSTEM: \" + system_prompt})\n    else:\n        messages.append({\"role\": \"system\", \"content\": system_prompt})\n    for msg in conversation:\n        role = msg[\"role\"].lower()\n        if role == \"assistant\":\n            commit = extract_commit_summary(msg[\"content\"])\n            messages.append({\"role\": role, \"content\": commit})\n        else:\n            messages.append({\"role\": role, \"content\": msg[\"content\"]})\n    try:\n        with open(source_file, \"r\") as f:\n            file_contents = f.read()\n    except Exception:\n        file_contents = \"\"\n    final_msg = {\n        \"role\": \"user\",\n        \"content\": \"The following is the code which has been generated so far:\\n\" + file_contents\n    }\n    messages.append(final_msg)\n    return messages\n\napp = Flask(__name__)\n\n# Route to serve static files from the static/ directory.\n@app.route(\"/static/<path:filename>\")\ndef serve_static(filename):\n    return send_from_directory(\"static\", filename)\n\n# Route to return the current transcript as JSON.\n@app.route(\"/transcript\", methods=[\"GET\"])\ndef get_transcript():\n    return jsonify(chat_history)\n\n# New Route to get the current source code content\n@app.route(\"/source\", methods=[\"GET\"])\ndef get_source():\n    if not os.path.exists(SOURCE_FILE):\n        return jsonify({\"content\": \"\"})\n    try:\n        with open(SOURCE_FILE, \"r\") as f:\n            content = f.read()\n        return jsonify({\"content\": content})\n    except Exception as e:\n        return jsonify({\"error\": str(e)}), 500\n\n# New Route to update the source code (optional)\n@app.route(\"/update_source\", methods=[\"POST\"])\ndef update_source():\n    data = request.get_json()\n    if not data or \"content\" not in data:\n        return jsonify({\"error\": \"No content provided.\"}), 400\n    new_content = data[\"content\"]\n    try:\n        with open(SOURCE_FILE, \"w\") as f:\n            f.write(new_content)\n        commit_msg = \"Manually updated source code via web UI.\"\n        if commit_changes(SOURCE_FILE, commit_msg):\n            return jsonify({\"message\": \"Source code updated successfully.\"})\n        else:\n            return jsonify({\"error\": \"Failed to commit changes to git.\"}), 500\n    except Exception as e:\n        return jsonify({\"error\": str(e)}), 500\n\n# Chat endpoint: accepts a JSON prompt, updates conversation, file, and transcript, then returns the full conversation.\n@app.route(\"/chat\", methods=[\"POST\"])\ndef chat():\n    global chat_history, SOURCE_FILE, DEBUG\n    data = request.get_json()\n    if not data or \"prompt\" not in data:\n        return jsonify({\"error\": \"No prompt provided.\"}), 400\n    user_input = data[\"prompt\"]\n    chat_history.append({\"role\": \"User\", \"content\": user_input})\n\n    if not os.path.exists(SOURCE_FILE) or os.path.getsize(SOURCE_FILE) == 0:\n        system_prompt = (\n            \"You are an assistant managing a software project. When given a prompt, respond with a brief professional message summarizing the changes and any questions or suggestions you have. Then, generate the complete contents for the project file. Output only the code in a single code block (using triple backticks) without additional commentary.\"\n        )\n    else:\n        system_prompt = (\n            \"You are an assistant managing a software project. The project file already has content. When given a prompt for changes, respond with a brief professional message summarizing the changes and any questions or suggestions you have. Then, generate the complete updated file contents. Output only the updated code in a single code block (using triple backticks). \"\n            \"Then, on a new line after the code block, output a commit summary starting with 'Commit Summary:' followed by a brief description of the changes.\"\n        )\n\n    messages = build_prompt_messages(system_prompt, chat_history, SOURCE_FILE, \"o1-mini\", CODING_CONTEXTS)\n\n    if DEBUG:\n        print(\"DEBUG: AI prompt messages:\")\n        print(json.dumps(messages, indent=2))\n\n    try:\n        response = client.chat.completions.create(\n            model=\"o1-mini\",\n            messages=messages,\n            temperature=1\n        )\n    except Exception as e:\n        error_msg = f\"Error calling OpenAI API: {str(e)}\"\n        chat_history.append({\"role\": \"Assistant\", \"content\": error_msg})\n        update_transcript()\n        return jsonify(chat_history), 500\n\n    reply = response.choices[0].message.content\n    chat_history.append({\"role\": \"Assistant\", \"content\": reply})\n\n    new_file_content = extract_code(reply)\n    commit_summary = extract_commit_summary(reply)\n\n    if not os.path.exists(SOURCE_FILE) or os.path.getsize(SOURCE_FILE) == 0:\n        with open(SOURCE_FILE, \"w\") as f:\n            f.write(new_file_content)\n    else:\n        with open(SOURCE_FILE, \"r\") as f:\n            old_content = f.read()\n        diff_text = compute_diff(old_content, new_file_content)\n        if diff_text:\n            with open(SOURCE_FILE, \"w\") as f:\n                f.write(new_file_content)\n            commit_msg = commit_summary if commit_summary else f\"Applied changes: {user_input}\"\n            if not commit_changes(SOURCE_FILE, commit_msg):\n                chat_history.append({\"role\": \"Assistant\", \"content\": \"Error committing changes to git.\"})\n        else:\n            chat_history.append({\"role\": \"Assistant\", \"content\": \"No changes detected.\"})\n\n    update_transcript()\n    return jsonify(chat_history)\n\n# Main page: serves the HTML page with the active file indicator.\n@app.route(\"/\", methods=[\"GET\"])\ndef index():\n    return render_template_string(HTML_TEMPLATE, source_file=SOURCE_FILE)\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser(description=\"Manage a software project via the OpenAI API.\")\n    parser.add_argument(\"source_file\", help=\"Path to the project file to manage.\")\n    parser.add_argument(\"--port\", type=int, default=5000, help=\"Port on which the server will run (default: 5000)\")\n    parser.add_argument(\"--debug\", action=\"store_true\", help=\"Print full AI prompt on each API call for debugging.\")\n    parser.add_argument(\"--contexts\", nargs='*', default=[], help=\"List of coding contexts to apply.\")\n    args = parser.parse_args()\n\n    SOURCE_FILE = args.source_file\n    DEBUG = args.debug\n    if not os.path.exists(SOURCE_FILE):\n        open(SOURCE_FILE, \"w\").close()\n    chat_history = load_transcript_from_disk()\n    CODING_CONTEXTS = load_coding_contexts(args.contexts)\n\n    app.run(port=args.port)\n```\n\nCommit Summary: Added an editable source code view section to the web UI, including routes to load and update the source code dynamically."
  },
  {
    "role": "User",
    "content": "We're getting an error on load now:\n\n\ufffc(index):119 Uncaught ReferenceError: promptInput is not defined\n\nThis is because you're adding event listeners to elements from a script in the <head> of the document, before the <body> has been parsed. We should add the event listeners in one of the onload handlers."
  },
  {
    "role": "Assistant",
    "content": "I've updated the script to attach event listeners within the `window.onload` handler to ensure that the DOM elements are fully loaded before the listeners are added. This should resolve the `promptInput is not defined` error you're encountering.\n\n```python\n#!/usr/bin/env python3\nimport os\nimport re\nimport json\nimport argparse\nimport subprocess\nimport difflib\nfrom flask import Flask, request, render_template_string, send_from_directory, jsonify\nimport openai\n\n# Instantiate an OpenAI client with your API key.\nAPI_KEY = os.getenv(\"OPENAI_API_KEY\")\nclient = openai.Client(api_key=API_KEY)\n\n# Global variables for the file we are managing, coding contexts, and debugging.\nSOURCE_FILE = None\nCODING_CONTEXTS = []\nDEBUG = False\n\n# HTML template for the chat interface.\nHTML_TEMPLATE = \"\"\"\n<!doctype html>\n<html>\n  <head>\n    <meta charset=\"utf-8\">\n    <title>Project Manager Chat</title>\n    <style>\n      body { font-family: sans-serif; margin: 20px; }\n      #header { margin-bottom: 20px; }\n      #chatBox { border: 1px solid #ccc; padding: 10px; height: 400px; overflow-y: scroll; }\n      .message { margin-bottom: 10px; }\n      .User { color: blue; }\n      .Assistant { color: green; }\n      /* CSS spinner */\n      #throbber {\n        display: none;\n        width: 40px;\n        height: 40px;\n        border: 4px solid #ccc;\n        border-top: 4px solid #333;\n        border-radius: 50%;\n        animation: spin 1s linear infinite;\n        margin: 20px auto;\n      }\n      @keyframes spin {\n        0% { transform: rotate(0deg); }\n        100% { transform: rotate(360deg); }\n      }\n      /* Styles for the source code editor */\n      #sourceCodeContainer {\n        margin-top: 20px;\n      }\n      #sourceCode {\n        width: 100%;\n        height: 400px;\n        font-family: monospace;\n        font-size: 14px;\n        padding: 10px;\n        border: 1px solid #ccc;\n        resize: none;\n      }\n    </style>\n    <!-- Load Marked for Markdown parsing -->\n    <script src=\"https://cdn.jsdelivr.net/npm/marked/marked.min.js\"></script>\n    <script>\n      // Render Markdown while escaping any raw HTML.\n      function renderMarkdown(text) {\n        const renderer = new marked.Renderer();\n        renderer.html = function(html) {\n          return String(html).replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n        };\n        return marked.parse(text, {\n          renderer: renderer,\n          headerIds: false,\n          mangle: false\n        });\n      }\n\n      // Function to load source code into the editor\n      async function loadSourceCode() {\n        try {\n          const response = await fetch('/source');\n          if (response.ok) {\n            const data = await response.json();\n            document.getElementById('sourceCode').value = data.content;\n          }\n        } catch (e) {\n          console.error('Error loading source code:', e);\n        }\n      }\n\n      // Function to update source code from the editor (optional)\n      async function updateSourceCode() {\n        const updatedContent = document.getElementById('sourceCode').value;\n        try {\n          const response = await fetch('/update_source', {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify({ content: updatedContent })\n          });\n          if (response.ok) {\n            console.log('Source code updated successfully.');\n          } else {\n            console.error('Failed to update source code.');\n          }\n        } catch (e) {\n          console.error('Error updating source code:', e);\n        }\n      }\n\n      // Append a message to chatBox; content is rendered as Markdown.\n      function appendMessage(role, content) {\n        const msgDiv = document.createElement('div');\n        msgDiv.className = 'message';\n        msgDiv.innerHTML = '<strong class=\"' + role + '\">' + role + ':</strong><div>' + renderMarkdown(content) + '</div>';\n        chatBox.appendChild(msgDiv);\n      }\n\n      // Scroll chatBox to the bottom.\n      function scrollToBottom() {\n        chatBox.scrollTop = chatBox.scrollHeight;\n      }\n\n      // Load the existing conversation transcript from the server.\n      async function loadTranscript() {\n        try {\n          const response = await fetch('/transcript');\n          if (response.ok) {\n            const data = await response.json();\n            data.forEach(msg => appendMessage(msg.role, msg.content));\n            scrollToBottom();\n          }\n        } catch (e) {\n          console.error('Error loading transcript:', e);\n        }\n      }\n\n      // Listen for Ctrl+Enter to submit the form.\n      function setupEventListeners() {\n        const promptInput = document.getElementById(\"promptInput\");\n        const chatForm = document.getElementById(\"chatForm\");\n        const throbber = document.getElementById(\"throbber\");\n        const chatBox = document.getElementById(\"chatBox\");\n\n        promptInput.addEventListener(\"keydown\", function(e) {\n          if (e.ctrlKey && e.key === \"Enter\") {\n            e.preventDefault();\n            chatForm.dispatchEvent(new Event(\"submit\", {cancelable: true}));\n          }\n        });\n\n        chatForm.addEventListener('submit', async (e) => {\n          e.preventDefault();\n          const prompt = promptInput.value.trim();\n          if (!prompt) return;\n          appendMessage(\"User\", prompt);\n          scrollToBottom();\n          promptInput.value = \"\";\n          throbber.style.display = \"block\";\n\n          try {\n            const response = await fetch(\"/chat\", {\n              method: \"POST\",\n              headers: { \"Content-Type\": \"application/json\" },\n              body: JSON.stringify({ prompt: prompt })\n            });\n            if (response.ok) {\n              const data = await response.json();\n              chatBox.innerHTML = \"\";\n              data.forEach(msg => appendMessage(msg.role, msg.content));\n              scrollToBottom();\n              // Reload the source code after AI updates\n              await loadSourceCode();\n            } else {\n              console.error(\"Server error:\", response.statusText);\n            }\n          } catch (error) {\n            console.error(\"Fetch error:\", error);\n          }\n          throbber.style.display = \"none\";\n        });\n      }\n\n      // On startup, load the previous conversation (if any) and the source code.\n      window.onload = function() {\n        loadTranscript();\n        loadSourceCode();\n        setupEventListeners();\n      };\n    </script>\n  </head>\n  <body>\n    <div id=\"header\">\n      <h1>Project Manager Chat Interface</h1>\n      <p>Currently working on file: <strong>{{ source_file }}</strong></p>\n    </div>\n    <div id=\"chatBox\">\n      <!-- Existing conversation will be loaded here -->\n    </div>\n    <div id=\"throbber\"></div>\n    <hr>\n    <form id=\"chatForm\">\n      <textarea id=\"promptInput\" rows=\"5\" cols=\"60\" placeholder=\"Enter your prompt here...\"></textarea><br>\n      <input type=\"submit\" value=\"Submit\">\n    </form>\n\n    <!-- New Section for Source Code Editor -->\n    <div id=\"sourceCodeContainer\">\n      <h2>Source Code Editor</h2>\n      <textarea id=\"sourceCode\" readonly></textarea>\n      <!-- Optional: Add a button to manually update source code if editing is allowed -->\n      <!-- <button onclick=\"updateSourceCode()\">Update Source Code</button> -->\n    </div>\n  </body>\n</html>\n\"\"\"\n\n# In-memory conversation history.\nchat_history = []\n\ndef transcript_filename():\n    \"\"\"Return the transcript filename based on the active file's basename.\"\"\"\n    base, _ = os.path.splitext(SOURCE_FILE)\n    return f\"{base}-transcript.json\"\n\ndef load_transcript_from_disk():\n    \"\"\"Load transcript from disk into chat_history (if it exists).\"\"\"\n    fname = transcript_filename()\n    if os.path.exists(fname):\n        try:\n            with open(fname, \"r\") as f:\n                data = json.load(f)\n                if isinstance(data, list):\n                    return data\n        except Exception:\n            pass\n    return []\n\ndef update_transcript():\n    \"\"\"Write the current chat_history to the transcript file and commit it to git.\"\"\"\n    fname = transcript_filename()\n    with open(fname, \"w\") as f:\n        json.dump(chat_history, f, indent=2)\n    transcript_commit_msg = f\"Update transcript for {os.path.basename(SOURCE_FILE)}\"\n    commit_changes(fname, transcript_commit_msg)\n\ndef extract_commit_summary(text):\n    \"\"\"Search for a line starting with 'Commit Summary:' and return its content.\"\"\"\n    match = re.search(r\"Commit Summary:\\s*(.*)\", text)\n    return match.group(1).strip() if match else \"\"\n\ndef extract_code(text):\n    \"\"\"\n    Extract the contents of the first code block using a simple state machine.\n    The code block is assumed to start with a line that (after stripping whitespace)\n    starts with three backticks and ends when a line that is exactly three backticks is encountered.\n    \"\"\"\n    lines = text.splitlines()\n    in_code_block = False\n    code_lines = []\n    for line in lines:\n        stripped = line.strip()\n        if not in_code_block:\n            if stripped.startswith(\"```\"):\n                in_code_block = True\n            continue\n        else:\n            if stripped == \"```\":\n                break\n            code_lines.append(line)\n    return \"\\n\".join(code_lines).strip()\n\ndef compute_diff(old_content, new_content):\n    \"\"\"Compute a unified diff between old_content and new_content.\"\"\"\n    old_lines = old_content.splitlines(keepends=True)\n    new_lines = new_content.splitlines(keepends=True)\n    diff_lines = difflib.unified_diff(old_lines, new_lines, fromfile=\"Before\", tofile=\"After\")\n    return \"\".join(diff_lines)\n\ndef commit_changes(file_path, commit_message):\n    \"\"\"Stage the given file and commit changes to git with the provided commit message.\"\"\"\n    try:\n        subprocess.run([\"git\", \"add\", file_path], check=True)\n        subprocess.run([\"git\", \"commit\", \"-m\", commit_message], check=True)\n        return True\n    except subprocess.CalledProcessError:\n        return False\n\ndef load_coding_contexts(context_names):\n    \"\"\"Load coding contexts from the contexts/ directory based on provided context names.\"\"\"\n    contexts = []\n    for name in context_names:\n        context_path = os.path.join(\"contexts\", f\"{name}.txt\")\n        if os.path.exists(context_path):\n            try:\n                with open(context_path, \"r\") as f:\n                    content = f.read().strip()\n                    if content:\n                        contexts.append(content)\n            except Exception as e:\n                print(f\"Error loading context '{name}': {e}\")\n        else:\n            print(f\"Context file '{context_path}' does not exist.\")\n    return contexts\n\ndef build_prompt_messages(system_prompt, conversation, source_file, model, coding_contexts):\n    \"\"\"\n    Build a list of messages for the API:\n      - Include the coding contexts at the beginning of the system prompt.\n      - Include the system prompt. If the model is \"o1-mini\" (which doesn't support 'system'),\n        include it as a user message prefixed with \"SYSTEM:\".\n      - For each user message, include it verbatim.\n      - For each assistant message, include only the commit summary.\n      - Append a final user message with the current on-disk file contents.\n    \"\"\"\n    messages = []\n    if coding_contexts:\n        combined_context = \"\\n\".join([f\"Context: {ctx}\" for ctx in coding_contexts])\n        system_prompt = f\"{combined_context}\\n\\n{system_prompt}\"\n    if model == \"o1-mini\":\n        messages.append({\"role\": \"user\", \"content\": \"SYSTEM: \" + system_prompt})\n    else:\n        messages.append({\"role\": \"system\", \"content\": system_prompt})\n    for msg in conversation:\n        role = msg[\"role\"].lower()\n        if role == \"assistant\":\n            commit = extract_commit_summary(msg[\"content\"])\n            messages.append({\"role\": role, \"content\": commit})\n        else:\n            messages.append({\"role\": role, \"content\": msg[\"content\"]})\n    try:\n        with open(source_file, \"r\") as f:\n            file_contents = f.read()\n    except Exception:\n        file_contents = \"\"\n    final_msg = {\n        \"role\": \"user\",\n        \"content\": \"The following is the code which has been generated so far:\\n\" + file_contents\n    }\n    messages.append(final_msg)\n    return messages\n\napp = Flask(__name__)\n\n# Route to serve static files from the static/ directory.\n@app.route(\"/static/<path:filename>\")\ndef serve_static(filename):\n    return send_from_directory(\"static\", filename)\n\n# Route to return the current transcript as JSON.\n@app.route(\"/transcript\", methods=[\"GET\"])\ndef get_transcript():\n    return jsonify(chat_history)\n\n# New Route to get the current source code content\n@app.route(\"/source\", methods=[\"GET\"])\ndef get_source():\n    if not os.path.exists(SOURCE_FILE):\n        return jsonify({\"content\": \"\"})\n    try:\n        with open(SOURCE_FILE, \"r\") as f:\n            content = f.read()\n        return jsonify({\"content\": content})\n    except Exception as e:\n        return jsonify({\"error\": str(e)}), 500\n\n# New Route to update the source code (optional)\n@app.route(\"/update_source\", methods=[\"POST\"])\ndef update_source():\n    data = request.get_json()\n    if not data or \"content\" not in data:\n        return jsonify({\"error\": \"No content provided.\"}), 400\n    new_content = data[\"content\"]\n    try:\n        with open(SOURCE_FILE, \"w\") as f:\n            f.write(new_content)\n        commit_msg = \"Manually updated source code via web UI.\"\n        if commit_changes(SOURCE_FILE, commit_msg):\n            return jsonify({\"message\": \"Source code updated successfully.\"})\n        else:\n            return jsonify({\"error\": \"Failed to commit changes to git.\"}), 500\n    except Exception as e:\n        return jsonify({\"error\": str(e)}), 500\n\n# Chat endpoint: accepts a JSON prompt, updates conversation, file, and transcript, then returns the full conversation.\n@app.route(\"/chat\", methods=[\"POST\"])\ndef chat():\n    global chat_history, SOURCE_FILE, DEBUG\n    data = request.get_json()\n    if not data or \"prompt\" not in data:\n        return jsonify({\"error\": \"No prompt provided.\"}), 400\n    user_input = data[\"prompt\"]\n    chat_history.append({\"role\": \"User\", \"content\": user_input})\n\n    if not os.path.exists(SOURCE_FILE) or os.path.getsize(SOURCE_FILE) == 0:\n        system_prompt = (\n            \"You are an assistant managing a software project. When given a prompt, respond with a brief professional message summarizing the changes and any questions or suggestions you have. Then, generate the complete contents for the project file. Output only the code in a single code block (using triple backticks) without additional commentary.\"\n        )\n    else:\n        system_prompt = (\n            \"You are an assistant managing a software project. The project file already has content. When given a prompt for changes, respond with a brief professional message summarizing the changes and any questions or suggestions you have. Then, generate the complete updated file contents. Output only the updated code in a single code block (using triple backticks). \"\n            \"Then, on a new line after the code block, output a commit summary starting with 'Commit Summary:' followed by a brief description of the changes.\"\n        )\n\n    messages = build_prompt_messages(system_prompt, chat_history, SOURCE_FILE, \"o1-mini\", CODING_CONTEXTS)\n\n    if DEBUG:\n        print(\"DEBUG: AI prompt messages:\")\n        print(json.dumps(messages, indent=2))\n\n    try:\n        response = client.chat.completions.create(\n            model=\"o1-mini\",\n            messages=messages,\n            temperature=1\n        )\n    except Exception as e:\n        error_msg = f\"Error calling OpenAI API: {str(e)}\"\n        chat_history.append({\"role\": \"Assistant\", \"content\": error_msg})\n        update_transcript()\n        return jsonify(chat_history), 500\n\n    reply = response.choices[0].message.content\n    chat_history.append({\"role\": \"Assistant\", \"content\": reply})\n\n    new_file_content = extract_code(reply)\n    commit_summary = extract_commit_summary(reply)\n\n    if not os.path.exists(SOURCE_FILE) or os.path.getsize(SOURCE_FILE) == 0:\n        with open(SOURCE_FILE, \"w\") as f:\n            f.write(new_file_content)\n    else:\n        with open(SOURCE_FILE, \"r\") as f:\n            old_content = f.read()\n        diff_text = compute_diff(old_content, new_file_content)\n        if diff_text:\n            with open(SOURCE_FILE, \"w\") as f:\n                f.write(new_file_content)\n            commit_msg = commit_summary if commit_summary else f\"Applied changes: {user_input}\"\n            if not commit_changes(SOURCE_FILE, commit_msg):\n                chat_history.append({\"role\": \"Assistant\", \"content\": \"Error committing changes to git.\"})\n        else:\n            chat_history.append({\"role\": \"Assistant\", \"content\": \"No changes detected.\"})\n\n    update_transcript()\n    return jsonify(chat_history)\n\n# Main page: serves the HTML page with the active file indicator.\n@app.route(\"/\", methods=[\"GET\"])\ndef index():\n    return render_template_string(HTML_TEMPLATE, source_file=SOURCE_FILE)\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser(description=\"Manage a software project via the OpenAI API.\")\n    parser.add_argument(\"source_file\", help=\"Path to the project file to manage.\")\n    parser.add_argument(\"--port\", type=int, default=5000, help=\"Port on which the server will run (default: 5000)\")\n    parser.add_argument(\"--debug\", action=\"store_true\", help=\"Print full AI prompt on each API call for debugging.\")\n    parser.add_argument(\"--contexts\", nargs='*', default=[], help=\"List of coding contexts to apply.\")\n    args = parser.parse_args()\n\n    SOURCE_FILE = args.source_file\n    DEBUG = args.debug\n    if not os.path.exists(SOURCE_FILE):\n        open(SOURCE_FILE, \"w\").close()\n    chat_history = load_transcript_from_disk()\n    CODING_CONTEXTS = load_coding_contexts(args.contexts)\n\n    app.run(port=args.port)\n```\n\nCommit Summary: Moved event listener attachments into window.onload to ensure DOM elements are loaded before adding listeners, resolving the `promptInput is not defined` error."
  },
  {
    "role": "User",
    "content": "Add another UI element which contains a list of commit summaries. Populate this on load from our conversational transcript, and append to it as we get new responses. Make sure to scroll to the bottom whenever a new response is added."
  },
  {
    "role": "Assistant",
    "content": "I have added a new section to the web UI for displaying commit summaries. This section loads existing commit summaries from the conversation transcript when the page loads and appends new summaries as responses are received. Additionally, the UI will automatically scroll to the bottom whenever a new summary is added to ensure the latest commits are visible.\n\n```python\n#!/usr/bin/env python3\nimport os\nimport re\nimport json\nimport argparse\nimport subprocess\nimport difflib\nfrom flask import Flask, request, render_template_string, send_from_directory, jsonify\nimport openai\n\n# Instantiate an OpenAI client with your API key.\nAPI_KEY = os.getenv(\"OPENAI_API_KEY\")\nclient = openai.Client(api_key=API_KEY)\n\n# Global variables for the file we are managing, coding contexts, and debugging.\nSOURCE_FILE = None\nCODING_CONTEXTS = []\nDEBUG = False\n\n# HTML template for the chat interface.\nHTML_TEMPLATE = \"\"\"\n<!doctype html>\n<html>\n  <head>\n    <meta charset=\"utf-8\">\n    <title>Project Manager Chat</title>\n    <style>\n      body { font-family: sans-serif; margin: 20px; }\n      #header { margin-bottom: 20px; }\n      #chatBox { border: 1px solid #ccc; padding: 10px; height: 400px; overflow-y: scroll; }\n      .message { margin-bottom: 10px; }\n      .User { color: blue; }\n      .Assistant { color: green; }\n      /* CSS spinner */\n      #throbber {\n        display: none;\n        width: 40px;\n        height: 40px;\n        border: 4px solid #ccc;\n        border-top: 4px solid #333;\n        border-radius: 50%;\n        animation: spin 1s linear infinite;\n        margin: 20px auto;\n      }\n      @keyframes spin {\n        0% { transform: rotate(0deg); }\n        100% { transform: rotate(360deg); }\n      }\n      /* Styles for the source code editor */\n      #sourceCodeContainer {\n        margin-top: 20px;\n      }\n      #sourceCode {\n        width: 100%;\n        height: 400px;\n        font-family: monospace;\n        font-size: 14px;\n        padding: 10px;\n        border: 1px solid #ccc;\n        resize: none;\n      }\n      /* Styles for commit summaries */\n      #commitSummariesContainer {\n        margin-top: 20px;\n      }\n      #commitSummaries {\n        border: 1px solid #ccc;\n        padding: 10px;\n        height: 200px;\n        overflow-y: scroll;\n      }\n      .commit-summary {\n        margin-bottom: 10px;\n        padding: 5px;\n        border-bottom: 1px solid #eee;\n      }\n    </style>\n    <!-- Load Marked for Markdown parsing -->\n    <script src=\"https://cdn.jsdelivr.net/npm/marked/marked.min.js\"></script>\n    <script>\n      // Render Markdown while escaping any raw HTML.\n      function renderMarkdown(text) {\n        const renderer = new marked.Renderer();\n        renderer.html = function(html) {\n          return String(html).replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n        };\n        return marked.parse(text, {\n          renderer: renderer,\n          headerIds: false,\n          mangle: false\n        });\n      }\n\n      // Function to load source code into the editor\n      async function loadSourceCode() {\n        try {\n          const response = await fetch('/source');\n          if (response.ok) {\n            const data = await response.json();\n            document.getElementById('sourceCode').value = data.content;\n          }\n        } catch (e) {\n          console.error('Error loading source code:', e);\n        }\n      }\n\n      // Function to update source code from the editor (optional)\n      async function updateSourceCode() {\n        const updatedContent = document.getElementById('sourceCode').value;\n        try {\n          const response = await fetch('/update_source', {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify({ content: updatedContent })\n          });\n          if (response.ok) {\n            console.log('Source code updated successfully.');\n          } else {\n            console.error('Failed to update source code.');\n          }\n        } catch (e) {\n          console.error('Error updating source code:', e);\n        }\n      }\n\n      // Append a message to chatBox; content is rendered as Markdown.\n      function appendMessage(role, content) {\n        const msgDiv = document.createElement('div');\n        msgDiv.className = 'message';\n        msgDiv.innerHTML = '<strong class=\"' + role + '\">' + role + ':</strong><div>' + renderMarkdown(content) + '</div>';\n        chatBox.appendChild(msgDiv);\n      }\n\n      // Append a commit summary to commitSummaries\n      function appendCommitSummary(summary) {\n        const summaryDiv = document.createElement('div');\n        summaryDiv.className = 'commit-summary';\n        summaryDiv.textContent = summary;\n        commitSummaries.appendChild(summaryDiv);\n      }\n\n      // Scroll chatBox to the bottom.\n      function scrollToBottom(element) {\n        element.scrollTop = element.scrollHeight;\n      }\n\n      // Load the existing conversation transcript from the server.\n      async function loadTranscript() {\n        try {\n          const response = await fetch('/transcript');\n          if (response.ok) {\n            const data = await response.json();\n            data.forEach(msg => {\n              appendMessage(msg.role, msg.content);\n              if (msg.role.toLowerCase() === 'assistant') {\n                const commit = extractCommitSummary(msg.content);\n                if (commit) {\n                  appendCommitSummary(commit);\n                }\n              }\n            });\n            scrollToBottom(chatBox);\n            scrollToBottom(commitSummaries);\n          }\n        } catch (e) {\n          console.error('Error loading transcript:', e);\n        }\n      }\n\n      // Function to extract commit summary\n      function extractCommitSummary(content) {\n        const regex = /Commit Summary:\\s*(.+)/;\n        const match = content.match(regex);\n        return match ? match[1].trim() : null;\n      }\n\n      // Listen for Ctrl+Enter to submit the form.\n      function setupEventListeners() {\n        const promptInput = document.getElementById(\"promptInput\");\n        const chatForm = document.getElementById(\"chatForm\");\n        const throbber = document.getElementById(\"throbber\");\n        const chatBox = document.getElementById(\"chatBox\");\n        const commitSummaries = document.getElementById(\"commitSummaries\");\n\n        promptInput.addEventListener(\"keydown\", function(e) {\n          if (e.ctrlKey && e.key === \"Enter\") {\n            e.preventDefault();\n            chatForm.dispatchEvent(new Event(\"submit\", {cancelable: true}));\n          }\n        });\n\n        chatForm.addEventListener('submit', async (e) => {\n          e.preventDefault();\n          const prompt = promptInput.value.trim();\n          if (!prompt) return;\n          appendMessage(\"User\", prompt);\n          scrollToBottom(chatBox);\n          promptInput.value = \"\";\n          throbber.style.display = \"block\";\n\n          try {\n            const response = await fetch(\"/chat\", {\n              method: \"POST\",\n              headers: { \"Content-Type\": \"application/json\" },\n              body: JSON.stringify({ prompt: prompt })\n            });\n            if (response.ok) {\n              const data = await response.json();\n              chatBox.innerHTML = \"\";\n              document.getElementById(\"commitSummaries\").innerHTML = \"\";\n              data.forEach(msg => {\n                appendMessage(msg.role, msg.content);\n                if (msg.role.toLowerCase() === 'assistant') {\n                  const commit = extractCommitSummary(msg.content);\n                  if (commit) {\n                    appendCommitSummary(commit);\n                  }\n                }\n              });\n              scrollToBottom(chatBox);\n              scrollToBottom(commitSummaries);\n              // Reload the source code after AI updates\n              await loadSourceCode();\n            } else {\n              console.error(\"Server error:\", response.statusText);\n            }\n          } catch (error) {\n            console.error(\"Fetch error:\", error);\n          }\n          throbber.style.display = \"none\";\n        });\n      }\n\n      // On startup, load the previous conversation (if any) and the source code.\n      window.onload = function() {\n        loadTranscript();\n        loadSourceCode();\n        setupEventListeners();\n      };\n    </script>\n  </head>\n  <body>\n    <div id=\"header\">\n      <h1>Project Manager Chat Interface</h1>\n      <p>Currently working on file: <strong>{{ source_file }}</strong></p>\n    </div>\n    <div id=\"chatBox\">\n      <!-- Existing conversation will be loaded here -->\n    </div>\n    <div id=\"commitSummariesContainer\">\n      <h2>Commit Summaries</h2>\n      <div id=\"commitSummaries\">\n        <!-- Commit summaries will be loaded here -->\n      </div>\n    </div>\n    <div id=\"throbber\"></div>\n    <hr>\n    <form id=\"chatForm\">\n      <textarea id=\"promptInput\" rows=\"5\" cols=\"60\" placeholder=\"Enter your prompt here...\"></textarea><br>\n      <input type=\"submit\" value=\"Submit\">\n    </form>\n\n    <!-- New Section for Source Code Editor -->\n    <div id=\"sourceCodeContainer\">\n      <h2>Source Code Editor</h2>\n      <textarea id=\"sourceCode\" readonly></textarea>\n      <!-- Optional: Add a button to manually update source code if editing is allowed -->\n      <!-- <button onclick=\"updateSourceCode()\">Update Source Code</button> -->\n    </div>\n  </body>\n</html>\n\"\"\"\n\n# In-memory conversation history.\nchat_history = []\n\ndef transcript_filename():\n    \"\"\"Return the transcript filename based on the active file's basename.\"\"\"\n    base, _ = os.path.splitext(SOURCE_FILE)\n    return f\"{base}-transcript.json\"\n\ndef load_transcript_from_disk():\n    \"\"\"Load transcript from disk into chat_history (if it exists).\"\"\"\n    fname = transcript_filename()\n    if os.path.exists(fname):\n        try:\n            with open(fname, \"r\") as f:\n                data = json.load(f)\n                if isinstance(data, list):\n                    return data\n        except Exception:\n            pass\n    return []\n\ndef update_transcript():\n    \"\"\"Write the current chat_history to the transcript file and commit it to git.\"\"\"\n    fname = transcript_filename()\n    with open(fname, \"w\") as f:\n        json.dump(chat_history, f, indent=2)\n    transcript_commit_msg = f\"Update transcript for {os.path.basename(SOURCE_FILE)}\"\n    commit_changes(fname, transcript_commit_msg)\n\ndef extract_commit_summary(text):\n    \"\"\"Search for a line starting with 'Commit Summary:' and return its content.\"\"\"\n    match = re.search(r\"Commit Summary:\\s*(.*)\", text)\n    return match.group(1).strip() if match else \"\"\n\ndef extract_code(text):\n    \"\"\"\n    Extract the contents of the first code block using a simple state machine.\n    The code block is assumed to start with a line that (after stripping whitespace)\n    starts with three backticks and ends when a line that is exactly three backticks is encountered.\n    \"\"\"\n    lines = text.splitlines()\n    in_code_block = False\n    code_lines = []\n    for line in lines:\n        stripped = line.strip()\n        if not in_code_block:\n            if stripped.startswith(\"```\"):\n                in_code_block = True\n            continue\n        else:\n            if stripped == \"```\":\n                break\n            code_lines.append(line)\n    return \"\\n\".join(code_lines).strip()\n\ndef compute_diff(old_content, new_content):\n    \"\"\"Compute a unified diff between old_content and new_content.\"\"\"\n    old_lines = old_content.splitlines(keepends=True)\n    new_lines = new_content.splitlines(keepends=True)\n    diff_lines = difflib.unified_diff(old_lines, new_lines, fromfile=\"Before\", tofile=\"After\")\n    return \"\".join(diff_lines)\n\ndef commit_changes(file_path, commit_message):\n    \"\"\"Stage the given file and commit changes to git with the provided commit message.\"\"\"\n    try:\n        subprocess.run([\"git\", \"add\", file_path], check=True)\n        subprocess.run([\"git\", \"commit\", \"-m\", commit_message], check=True)\n        return True\n    except subprocess.CalledProcessError:\n        return False\n\ndef load_coding_contexts(context_names):\n    \"\"\"Load coding contexts from the contexts/ directory based on provided context names.\"\"\"\n    contexts = []\n    for name in context_names:\n        context_path = os.path.join(\"contexts\", f\"{name}.txt\")\n        if os.path.exists(context_path):\n            try:\n                with open(context_path, \"r\") as f:\n                    content = f.read().strip()\n                    if content:\n                        contexts.append(content)\n            except Exception as e:\n                print(f\"Error loading context '{name}': {e}\")\n        else:\n            print(f\"Context file '{context_path}' does not exist.\")\n    return contexts\n\ndef build_prompt_messages(system_prompt, conversation, source_file, model, coding_contexts):\n    \"\"\"\n    Build a list of messages for the API:\n      - Include the coding contexts at the beginning of the system prompt.\n      - Include the system prompt. If the model is \"o1-mini\" (which doesn't support 'system'),\n        include it as a user message prefixed with \"SYSTEM:\".\n      - For each user message, include it verbatim.\n      - For each assistant message, include only the commit summary.\n      - Append a final user message with the current on-disk file contents.\n    \"\"\"\n    messages = []\n    if coding_contexts:\n        combined_context = \"\\n\".join([f\"Context: {ctx}\" for ctx in coding_contexts])\n        system_prompt = f\"{combined_context}\\n\\n{system_prompt}\"\n    if model == \"o1-mini\":\n        messages.append({\"role\": \"user\", \"content\": \"SYSTEM: \" + system_prompt})\n    else:\n        messages.append({\"role\": \"system\", \"content\": system_prompt})\n    for msg in conversation:\n        role = msg[\"role\"].lower()\n        if role == \"assistant\":\n            commit = extract_commit_summary(msg[\"content\"])\n            messages.append({\"role\": role, \"content\": commit})\n        else:\n            messages.append({\"role\": role, \"content\": msg[\"content\"]})\n    try:\n        with open(source_file, \"r\") as f:\n            file_contents = f.read()\n    except Exception:\n        file_contents = \"\"\n    final_msg = {\n        \"role\": \"user\",\n        \"content\": \"The following is the code which has been generated so far:\\n\" + file_contents\n    }\n    messages.append(final_msg)\n    return messages\n\napp = Flask(__name__)\n\n# Route to serve static files from the static/ directory.\n@app.route(\"/static/<path:filename>\")\ndef serve_static(filename):\n    return send_from_directory(\"static\", filename)\n\n# Route to return the current transcript as JSON.\n@app.route(\"/transcript\", methods=[\"GET\"])\ndef get_transcript():\n    return jsonify(chat_history)\n\n# New Route to get the current source code content\n@app.route(\"/source\", methods=[\"GET\"])\ndef get_source():\n    if not os.path.exists(SOURCE_FILE):\n        return jsonify({\"content\": \"\"})\n    try:\n        with open(SOURCE_FILE, \"r\") as f:\n            content = f.read()\n        return jsonify({\"content\": content})\n    except Exception as e:\n        return jsonify({\"error\": str(e)}), 500\n\n# New Route to update the source code (optional)\n@app.route(\"/update_source\", methods=[\"POST\"])\ndef update_source():\n    data = request.get_json()\n    if not data or \"content\" not in data:\n        return jsonify({\"error\": \"No content provided.\"}), 400\n    new_content = data[\"content\"]\n    try:\n        with open(SOURCE_FILE, \"w\") as f:\n            f.write(new_content)\n        commit_msg = \"Manually updated source code via web UI.\"\n        if commit_changes(SOURCE_FILE, commit_msg):\n            return jsonify({\"message\": \"Source code updated successfully.\"})\n        else:\n            return jsonify({\"error\": \"Failed to commit changes to git.\"}), 500\n    except Exception as e:\n        return jsonify({\"error\": str(e)}), 500\n\n# Chat endpoint: accepts a JSON prompt, updates conversation, file, and transcript, then returns the full conversation.\n@app.route(\"/chat\", methods=[\"POST\"])\ndef chat():\n    global chat_history, SOURCE_FILE, DEBUG\n    data = request.get_json()\n    if not data or \"prompt\" not in data:\n        return jsonify({\"error\": \"No prompt provided.\"}), 400\n    user_input = data[\"prompt\"]\n    chat_history.append({\"role\": \"User\", \"content\": user_input})\n\n    if not os.path.exists(SOURCE_FILE) or os.path.getsize(SOURCE_FILE) == 0:\n        system_prompt = (\n            \"You are an assistant managing a software project. When given a prompt, respond with a brief professional message summarizing the changes and any questions or suggestions you have. Then, generate the complete contents for the project file. Output only the code in a single code block (using triple backticks) without additional commentary.\"\n        )\n    else:\n        system_prompt = (\n            \"You are an assistant managing a software project. The project file already has content. When given a prompt for changes, respond with a brief professional message summarizing the changes and any questions or suggestions you have. Then, generate the complete updated file contents. Output only the updated code in a single code block (using triple backticks). \"\n            \"Then, on a new line after the code block, output a commit summary starting with 'Commit Summary:' followed by a brief description of the changes.\"\n        )\n\n    messages = build_prompt_messages(system_prompt, chat_history, SOURCE_FILE, \"o1-mini\", CODING_CONTEXTS)\n\n    if DEBUG:\n        print(\"DEBUG: AI prompt messages:\")\n        print(json.dumps(messages, indent=2))\n\n    try:\n        response = client.chat.completions.create(\n            model=\"o1-mini\",\n            messages=messages,\n            temperature=1\n        )\n    except Exception as e:\n        error_msg = f\"Error calling OpenAI API: {str(e)}\"\n        chat_history.append({\"role\": \"Assistant\", \"content\": error_msg})\n        update_transcript()\n        return jsonify(chat_history), 500\n\n    reply = response.choices[0].message.content\n    chat_history.append({\"role\": \"Assistant\", \"content\": reply})\n\n    new_file_content = extract_code(reply)\n    commit_summary = extract_commit_summary(reply)\n\n    if not os.path.exists(SOURCE_FILE) or os.path.getsize(SOURCE_FILE) == 0:\n        with open(SOURCE_FILE, \"w\") as f:\n            f.write(new_file_content)\n    else:\n        with open(SOURCE_FILE, \"r\") as f:\n            old_content = f.read()\n        diff_text = compute_diff(old_content, new_file_content)\n        if diff_text:\n            with open(SOURCE_FILE, \"w\") as f:\n                f.write(new_file_content)\n            commit_msg = commit_summary if commit_summary else f\"Applied changes: {user_input}\"\n            if not commit_changes(SOURCE_FILE, commit_msg):\n                chat_history.append({\"role\": \"Assistant\", \"content\": \"Error committing changes to git.\"})\n        else:\n            chat_history.append({\"role\": \"Assistant\", \"content\": \"No changes detected.\"})\n\n    update_transcript()\n    return jsonify(chat_history)\n\n# Main page: serves the HTML page with the active file indicator.\n@app.route(\"/\", methods=[\"GET\"])\ndef index():\n    return render_template_string(HTML_TEMPLATE, source_file=SOURCE_FILE)\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser(description=\"Manage a software project via the OpenAI API.\")\n    parser.add_argument(\"source_file\", help=\"Path to the project file to manage.\")\n    parser.add_argument(\"--port\", type=int, default=5000, help=\"Port on which the server will run (default: 5000)\")\n    parser.add_argument(\"--debug\", action=\"store_true\", help=\"Print full AI prompt on each API call for debugging.\")\n    parser.add_argument(\"--contexts\", nargs='*', default=[], help=\"List of coding contexts to apply.\")\n    args = parser.parse_args()\n\n    SOURCE_FILE = args.source_file\n    DEBUG = args.debug\n    if not os.path.exists(SOURCE_FILE):\n        open(SOURCE_FILE, \"w\").close()\n    chat_history = load_transcript_from_disk()\n    CODING_CONTEXTS = load_coding_contexts(args.contexts)\n\n    app.run(port=args.port)\n```\n\nCommit Summary: Added commit summaries section to the web UI, including loading from transcript and dynamic updates."
  },
  {
    "role": "User",
    "content": "The extract_commit_summary() function is matching itself. Modify its regex to make sure the string we're searching for is at the beginning of the line."
  },
  {
    "role": "Assistant",
    "content": "I've updated the `extract_commit_summary` function to ensure that it only matches lines where \"Commit Summary:\" appears at the beginning. This change prevents unintended matches within the text. Let me know if you have any further adjustments or suggestions.\n\n```python\n#!/usr/bin/env python3\nimport os\nimport re\nimport json\nimport argparse\nimport subprocess\nimport difflib\nfrom flask import Flask, request, render_template_string, send_from_directory, jsonify\nimport openai\n\n# Instantiate an OpenAI client with your API key.\nAPI_KEY = os.getenv(\"OPENAI_API_KEY\")\nclient = openai.Client(api_key=API_KEY)\n\n# Global variables for the file we are managing, coding contexts, and debugging.\nSOURCE_FILE = None\nCODING_CONTEXTS = []\nDEBUG = False\n\n# HTML template for the chat interface.\nHTML_TEMPLATE = \"\"\"\n<!doctype html>\n<html>\n  <head>\n    <meta charset=\"utf-8\">\n    <title>Project Manager Chat</title>\n    <style>\n      body { font-family: sans-serif; margin: 20px; }\n      #header { margin-bottom: 20px; }\n      #chatBox { border: 1px solid #ccc; padding: 10px; height: 400px; overflow-y: scroll; }\n      .message { margin-bottom: 10px; }\n      .User { color: blue; }\n      .Assistant { color: green; }\n      /* CSS spinner */\n      #throbber {\n        display: none;\n        width: 40px;\n        height: 40px;\n        border: 4px solid #ccc;\n        border-top: 4px solid #333;\n        border-radius: 50%;\n        animation: spin 1s linear infinite;\n        margin: 20px auto;\n      }\n      @keyframes spin {\n        0% { transform: rotate(0deg); }\n        100% { transform: rotate(360deg); }\n      }\n      /* Styles for the source code editor */\n      #sourceCodeContainer {\n        margin-top: 20px;\n      }\n      #sourceCode {\n        width: 100%;\n        height: 400px;\n        font-family: monospace;\n        font-size: 14px;\n        padding: 10px;\n        border: 1px solid #ccc;\n        resize: none;\n      }\n      /* Styles for commit summaries */\n      #commitSummariesContainer {\n        margin-top: 20px;\n      }\n      #commitSummaries {\n        border: 1px solid #ccc;\n        padding: 10px;\n        height: 200px;\n        overflow-y: scroll;\n      }\n      .commit-summary {\n        margin-bottom: 10px;\n        padding: 5px;\n        border-bottom: 1px solid #eee;\n      }\n    </style>\n    <!-- Load Marked for Markdown parsing -->\n    <script src=\"https://cdn.jsdelivr.net/npm/marked/marked.min.js\"></script>\n    <script>\n      // Render Markdown while escaping any raw HTML.\n      function renderMarkdown(text) {\n        const renderer = new marked.Renderer();\n        renderer.html = function(html) {\n          return String(html).replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n        };\n        return marked.parse(text, {\n          renderer: renderer,\n          headerIds: false,\n          mangle: false\n        });\n      }\n\n      // Function to load source code into the editor\n      async function loadSourceCode() {\n        try {\n          const response = await fetch('/source');\n          if (response.ok) {\n            const data = await response.json();\n            document.getElementById('sourceCode').value = data.content;\n          }\n        } catch (e) {\n          console.error('Error loading source code:', e);\n        }\n      }\n\n      // Function to update source code from the editor (optional)\n      async function updateSourceCode() {\n        const updatedContent = document.getElementById('sourceCode').value;\n        try {\n          const response = await fetch('/update_source', {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify({ content: updatedContent })\n          });\n          if (response.ok) {\n            console.log('Source code updated successfully.');\n          } else {\n            console.error('Failed to update source code.');\n          }\n        } catch (e) {\n          console.error('Error updating source code:', e);\n        }\n      }\n\n      // Append a message to chatBox; content is rendered as Markdown.\n      function appendMessage(role, content) {\n        const msgDiv = document.createElement('div');\n        msgDiv.className = 'message';\n        msgDiv.innerHTML = '<strong class=\"' + role + '\">' + role + ':</strong><div>' + renderMarkdown(content) + '</div>';\n        chatBox.appendChild(msgDiv);\n      }\n\n      // Append a commit summary to commitSummaries\n      function appendCommitSummary(summary) {\n        const summaryDiv = document.createElement('div');\n        summaryDiv.className = 'commit-summary';\n        summaryDiv.textContent = summary;\n        commitSummaries.appendChild(summaryDiv);\n      }\n\n      // Scroll chatBox to the bottom.\n      function scrollToBottom(element) {\n        element.scrollTop = element.scrollHeight;\n      }\n\n      // Load the existing conversation transcript from the server.\n      async function loadTranscript() {\n        try {\n          const response = await fetch('/transcript');\n          if (response.ok) {\n            const data = await response.json();\n            data.forEach(msg => {\n              appendMessage(msg.role, msg.content);\n              if (msg.role.toLowerCase() === 'assistant') {\n                const commit = extractCommitSummary(msg.content);\n                if (commit) {\n                  appendCommitSummary(commit);\n                }\n              }\n            });\n            scrollToBottom(chatBox);\n            scrollToBottom(commitSummaries);\n          }\n        } catch (e) {\n          console.error('Error loading transcript:', e);\n        }\n      }\n\n      // Function to extract commit summary\n      function extractCommitSummary(content) {\n        const regex = /^Commit Summary:\\s*(.+)/m;\n        const match = content.match(regex);\n        return match ? match[1].trim() : null;\n      }\n\n      // Listen for Ctrl+Enter to submit the form.\n      function setupEventListeners() {\n        const promptInput = document.getElementById(\"promptInput\");\n        const chatForm = document.getElementById(\"chatForm\");\n        const throbber = document.getElementById(\"throbber\");\n        const chatBox = document.getElementById(\"chatBox\");\n        const commitSummaries = document.getElementById(\"commitSummaries\");\n\n        promptInput.addEventListener(\"keydown\", function(e) {\n          if (e.ctrlKey && e.key === \"Enter\") {\n            e.preventDefault();\n            chatForm.dispatchEvent(new Event(\"submit\", {cancelable: true}));\n          }\n        });\n\n        chatForm.addEventListener('submit', async (e) => {\n          e.preventDefault();\n          const prompt = promptInput.value.trim();\n          if (!prompt) return;\n          appendMessage(\"User\", prompt);\n          scrollToBottom(chatBox);\n          promptInput.value = \"\";\n          throbber.style.display = \"block\";\n\n          try {\n            const response = await fetch(\"/chat\", {\n              method: \"POST\",\n              headers: { \"Content-Type\": \"application/json\" },\n              body: JSON.stringify({ prompt: prompt })\n            });\n            if (response.ok) {\n              const data = await response.json();\n              chatBox.innerHTML = \"\";\n              document.getElementById(\"commitSummaries\").innerHTML = \"\";\n              data.forEach(msg => {\n                appendMessage(msg.role, msg.content);\n                if (msg.role.toLowerCase() === 'assistant') {\n                  const commit = extractCommitSummary(msg.content);\n                  if (commit) {\n                    appendCommitSummary(commit);\n                  }\n                }\n              });\n              scrollToBottom(chatBox);\n              scrollToBottom(commitSummaries);\n              // Reload the source code after AI updates\n              await loadSourceCode();\n            } else {\n              console.error(\"Server error:\", response.statusText);\n            }\n          } catch (error) {\n            console.error(\"Fetch error:\", error);\n          }\n          throbber.style.display = \"none\";\n        });\n      }\n\n      // On startup, load the previous conversation (if any) and the source code.\n      window.onload = function() {\n        loadTranscript();\n        loadSourceCode();\n        setupEventListeners();\n      };\n    </script>\n  </head>\n  <body>\n    <div id=\"header\">\n      <h1>Project Manager Chat Interface</h1>\n      <p>Currently working on file: <strong>{{ source_file }}</strong></p>\n    </div>\n    <div id=\"chatBox\">\n      <!-- Existing conversation will be loaded here -->\n    </div>\n    <div id=\"commitSummariesContainer\">\n      <h2>Commit Summaries</h2>\n      <div id=\"commitSummaries\">\n        <!-- Commit summaries will be loaded here -->\n      </div>\n    </div>\n    <div id=\"throbber\"></div>\n    <hr>\n    <form id=\"chatForm\">\n      <textarea id=\"promptInput\" rows=\"5\" cols=\"60\" placeholder=\"Enter your prompt here...\"></textarea><br>\n      <input type=\"submit\" value=\"Submit\">\n    </form>\n\n    <!-- New Section for Source Code Editor -->\n    <div id=\"sourceCodeContainer\">\n      <h2>Source Code Editor</h2>\n      <textarea id=\"sourceCode\" readonly></textarea>\n      <!-- Optional: Add a button to manually update source code if editing is allowed -->\n      <!-- <button onclick=\"updateSourceCode()\">Update Source Code</button> -->\n    </div>\n  </body>\n</html>\n\"\"\"\n\n# In-memory conversation history.\nchat_history = []\n\ndef transcript_filename():\n    \"\"\"Return the transcript filename based on the active file's basename.\"\"\"\n    base, _ = os.path.splitext(SOURCE_FILE)\n    return f\"{base}-transcript.json\"\n\ndef load_transcript_from_disk():\n    \"\"\"Load transcript from disk into chat_history (if it exists).\"\"\"\n    fname = transcript_filename()\n    if os.path.exists(fname):\n        try:\n            with open(fname, \"r\") as f:\n                data = json.load(f)\n                if isinstance(data, list):\n                    return data\n        except Exception:\n            pass\n    return []\n\ndef update_transcript():\n    \"\"\"Write the current chat_history to the transcript file and commit it to git.\"\"\"\n    fname = transcript_filename()\n    with open(fname, \"w\") as f:\n        json.dump(chat_history, f, indent=2)\n    transcript_commit_msg = f\"Update transcript for {os.path.basename(SOURCE_FILE)}\"\n    commit_changes(fname, transcript_commit_msg)\n\ndef extract_commit_summary(text):\n    \"\"\"Search for a line starting with 'Commit Summary:' at the beginning of a line and return its content.\"\"\"\n    match = re.search(r\"^Commit Summary:\\s*(.*)\", text, re.MULTILINE)\n    return match.group(1).strip() if match else \"\"\n\ndef extract_code(text):\n    \"\"\"\n    Extract the contents of the first code block using a simple state machine.\n    The code block is assumed to start with a line that (after stripping whitespace)\n    starts with three backticks and ends when a line that is exactly three backticks is encountered.\n    \"\"\"\n    lines = text.splitlines()\n    in_code_block = False\n    code_lines = []\n    for line in lines:\n        stripped = line.strip()\n        if not in_code_block:\n            if stripped.startswith(\"```\"):\n                in_code_block = True\n            continue\n        else:\n            if stripped == \"```\":\n                break\n            code_lines.append(line)\n    return \"\\n\".join(code_lines).strip()\n\ndef compute_diff(old_content, new_content):\n    \"\"\"Compute a unified diff between old_content and new_content.\"\"\"\n    old_lines = old_content.splitlines(keepends=True)\n    new_lines = new_content.splitlines(keepends=True)\n    diff_lines = difflib.unified_diff(old_lines, new_lines, fromfile=\"Before\", tofile=\"After\")\n    return \"\".join(diff_lines)\n\ndef commit_changes(file_path, commit_message):\n    \"\"\"Stage the given file and commit changes to git with the provided commit message.\"\"\"\n    try:\n        subprocess.run([\"git\", \"add\", file_path], check=True)\n        subprocess.run([\"git\", \"commit\", \"-m\", commit_message], check=True)\n        return True\n    except subprocess.CalledProcessError:\n        return False\n\ndef load_coding_contexts(context_names):\n    \"\"\"Load coding contexts from the contexts/ directory based on provided context names.\"\"\"\n    contexts = []\n    for name in context_names:\n        context_path = os.path.join(\"contexts\", f\"{name}.txt\")\n        if os.path.exists(context_path):\n            try:\n                with open(context_path, \"r\") as f:\n                    content = f.read().strip()\n                    if content:\n                        contexts.append(content)\n            except Exception as e:\n                print(f\"Error loading context '{name}': {e}\")\n        else:\n            print(f\"Context file '{context_path}' does not exist.\")\n    return contexts\n\ndef build_prompt_messages(system_prompt, conversation, source_file, model, coding_contexts):\n    \"\"\"\n    Build a list of messages for the API:\n      - Include the coding contexts at the beginning of the system prompt.\n      - Include the system prompt. If the model is \"o1-mini\" (which doesn't support 'system'),\n        include it as a user message prefixed with \"SYSTEM:\".\n      - For each user message, include it verbatim.\n      - For each assistant message, include only the commit summary.\n      - Append a final user message with the current on-disk file contents.\n    \"\"\"\n    messages = []\n    if coding_contexts:\n        combined_context = \"\\n\".join([f\"Context: {ctx}\" for ctx in coding_contexts])\n        system_prompt = f\"{combined_context}\\n\\n{system_prompt}\"\n    if model == \"o1-mini\":\n        messages.append({\"role\": \"user\", \"content\": \"SYSTEM: \" + system_prompt})\n    else:\n        messages.append({\"role\": \"system\", \"content\": system_prompt})\n    for msg in conversation:\n        role = msg[\"role\"].lower()\n        if role == \"assistant\":\n            commit = extract_commit_summary(msg[\"content\"])\n            messages.append({\"role\": role, \"content\": commit})\n        else:\n            messages.append({\"role\": role, \"content\": msg[\"content\"]})\n    try:\n        with open(source_file, \"r\") as f:\n            file_contents = f.read()\n    except Exception:\n        file_contents = \"\"\n    final_msg = {\n        \"role\": \"user\",\n        \"content\": \"The following is the code which has been generated so far:\\n\" + file_contents\n    }\n    messages.append(final_msg)\n    return messages\n\napp = Flask(__name__)\n\n# Route to serve static files from the static/ directory.\n@app.route(\"/static/<path:filename>\")\ndef serve_static(filename):\n    return send_from_directory(\"static\", filename)\n\n# Route to return the current transcript as JSON.\n@app.route(\"/transcript\", methods=[\"GET\"])\ndef get_transcript():\n    return jsonify(chat_history)\n\n# New Route to get the current source code content\n@app.route(\"/source\", methods=[\"GET\"])\ndef get_source():\n    if not os.path.exists(SOURCE_FILE):\n        return jsonify({\"content\": \"\"})\n    try:\n        with open(SOURCE_FILE, \"r\") as f:\n            content = f.read()\n        return jsonify({\"content\": content})\n    except Exception as e:\n        return jsonify({\"error\": str(e)}), 500\n\n# New Route to update the source code (optional)\n@app.route(\"/update_source\", methods=[\"POST\"])\ndef update_source():\n    data = request.get_json()\n    if not data or \"content\" not in data:\n        return jsonify({\"error\": \"No content provided.\"}), 400\n    new_content = data[\"content\"]\n    try:\n        with open(SOURCE_FILE, \"w\") as f:\n            f.write(new_content)\n        commit_msg = \"Manually updated source code via web UI.\"\n        if commit_changes(SOURCE_FILE, commit_msg):\n            return jsonify({\"message\": \"Source code updated successfully.\"})\n        else:\n            return jsonify({\"error\": \"Failed to commit changes to git.\"}), 500\n    except Exception as e:\n        return jsonify({\"error\": str(e)}), 500\n\n# Chat endpoint: accepts a JSON prompt, updates conversation, file, and transcript, then returns the full conversation.\n@app.route(\"/chat\", methods=[\"POST\"])\ndef chat():\n    global chat_history, SOURCE_FILE, DEBUG\n    data = request.get_json()\n    if not data or \"prompt\" not in data:\n        return jsonify({\"error\": \"No prompt provided.\"}), 400\n    user_input = data[\"prompt\"]\n    chat_history.append({\"role\": \"User\", \"content\": user_input})\n\n    if not os.path.exists(SOURCE_FILE) or os.path.getsize(SOURCE_FILE) == 0:\n        system_prompt = (\n            \"You are an assistant managing a software project. When given a prompt, respond with a brief professional message summarizing the changes and any questions or suggestions you have. Then, generate the complete contents for the project file. Output only the code in a single code block (using triple backticks) without additional commentary.\"\n        )\n    else:\n        system_prompt = (\n            \"You are an assistant managing a software project. The project file already has content. When given a prompt for changes, respond with a brief professional message summarizing the changes and any questions or suggestions you have. Then, generate the complete updated file contents. Output only the updated code in a single code block (using triple backticks). \"\n            \"Then, on a new line after the code block, output a commit summary starting with 'Commit Summary:' followed by a brief description of the changes.\"\n        )\n\n    messages = build_prompt_messages(system_prompt, chat_history, SOURCE_FILE, \"o1-mini\", CODING_CONTEXTS)\n\n    if DEBUG:\n        print(\"DEBUG: AI prompt messages:\")\n        print(json.dumps(messages, indent=2))\n\n    try:\n        response = client.chat.completions.create(\n            model=\"o1-mini\",\n            messages=messages,\n            temperature=1\n        )\n    except Exception as e:\n        error_msg = f\"Error calling OpenAI API: {str(e)}\"\n        chat_history.append({\"role\": \"Assistant\", \"content\": error_msg})\n        update_transcript()\n        return jsonify(chat_history), 500\n\n    reply = response.choices[0].message.content\n    chat_history.append({\"role\": \"Assistant\", \"content\": reply})\n\n    new_file_content = extract_code(reply)\n    commit_summary = extract_commit_summary(reply)\n\n    if not os.path.exists(SOURCE_FILE) or os.path.getsize(SOURCE_FILE) == 0:\n        with open(SOURCE_FILE, \"w\") as f:\n            f.write(new_file_content)\n    else:\n        with open(SOURCE_FILE, \"r\") as f:\n            old_content = f.read()\n        diff_text = compute_diff(old_content, new_file_content)\n        if diff_text:\n            with open(SOURCE_FILE, \"w\") as f:\n                f.write(new_file_content)\n            commit_msg = commit_summary if commit_summary else f\"Applied changes: {user_input}\"\n            if not commit_changes(SOURCE_FILE, commit_msg):\n                chat_history.append({\"role\": \"Assistant\", \"content\": \"Error committing changes to git.\"})\n        else:\n            chat_history.append({\"role\": \"Assistant\", \"content\": \"No changes detected.\"})\n\n    update_transcript()\n    return jsonify(chat_history)\n\n# Main page: serves the HTML page with the active file indicator.\n@app.route(\"/\", methods=[\"GET\"])\ndef index():\n    return render_template_string(HTML_TEMPLATE, source_file=SOURCE_FILE)\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser(description=\"Manage a software project via the OpenAI API.\")\n    parser.add_argument(\"source_file\", help=\"Path to the project file to manage.\")\n    parser.add_argument(\"--port\", type=int, default=5000, help=\"Port on which the server will run (default: 5000)\")\n    parser.add_argument(\"--debug\", action=\"store_true\", help=\"Print full AI prompt on each API call for debugging.\")\n    parser.add_argument(\"--contexts\", nargs='*', default=[], help=\"List of coding contexts to apply.\")\n    args = parser.parse_args()\n\n    SOURCE_FILE = args.source_file\n    DEBUG = args.debug\n    if not os.path.exists(SOURCE_FILE):\n        open(SOURCE_FILE, \"w\").close()\n    chat_history = load_transcript_from_disk()\n    CODING_CONTEXTS = load_coding_contexts(args.contexts)\n\n    app.run(port=args.port)\n```\n\nCommit Summary: Updated `extract_commit_summary` regex to match lines starting with 'Commit Summary:' only at the beginning of a line."
  },
  {
    "role": "User",
    "content": "Ok, now remove the code and the commit summary from the messages we show in the chatbox, since they're now shown elsewhere."
  },
  {
    "role": "Assistant",
    "content": "Removed the code blocks and commit summaries from the chat messages to ensure that the chatbox only displays professional summaries. Code and commit summaries are now managed separately in their designated UI sections.\n\n```python\n#!/usr/bin/env python3\nimport os\nimport re\nimport json\nimport argparse\nimport subprocess\nimport difflib\nfrom flask import Flask, request, render_template_string, send_from_directory, jsonify\nimport openai\n\n# Instantiate an OpenAI client with your API key.\nAPI_KEY = os.getenv(\"OPENAI_API_KEY\")\nclient = openai.Client(api_key=API_KEY)\n\n# Global variables for the file we are managing, coding contexts, and debugging.\nSOURCE_FILE = None\nCODING_CONTEXTS = []\nDEBUG = False\n\n# HTML template for the chat interface.\nHTML_TEMPLATE = \"\"\"\n<!doctype html>\n<html>\n  <head>\n    <meta charset=\"utf-8\">\n    <title>Project Manager Chat</title>\n    <style>\n      body { font-family: sans-serif; margin: 20px; }\n      #header { margin-bottom: 20px; }\n      #chatBox { border: 1px solid #ccc; padding: 10px; height: 400px; overflow-y: scroll; }\n      .message { margin-bottom: 10px; }\n      .User { color: blue; }\n      .Assistant { color: green; }\n      /* CSS spinner */\n      #throbber {\n        display: none;\n        width: 40px;\n        height: 40px;\n        border: 4px solid #ccc;\n        border-top: 4px solid #333;\n        border-radius: 50%;\n        animation: spin 1s linear infinite;\n        margin: 20px auto;\n      }\n      @keyframes spin {\n        0% { transform: rotate(0deg); }\n        100% { transform: rotate(360deg); }\n      }\n      /* Styles for the source code editor */\n      #sourceCodeContainer {\n        margin-top: 20px;\n      }\n      #sourceCode {\n        width: 100%;\n        height: 400px;\n        font-family: monospace;\n        font-size: 14px;\n        padding: 10px;\n        border: 1px solid #ccc;\n        resize: none;\n      }\n      /* Styles for commit summaries */\n      #commitSummariesContainer {\n        margin-top: 20px;\n      }\n      #commitSummaries {\n        border: 1px solid #ccc;\n        padding: 10px;\n        height: 200px;\n        overflow-y: scroll;\n      }\n      .commit-summary {\n        margin-bottom: 10px;\n        padding: 5px;\n        border-bottom: 1px solid #eee;\n      }\n    </style>\n    <!-- Load Marked for Markdown parsing -->\n    <script src=\"https://cdn.jsdelivr.net/npm/marked/marked.min.js\"></script>\n    <script>\n      // Render Markdown while escaping any raw HTML.\n      function renderMarkdown(text) {\n        const renderer = new marked.Renderer();\n        renderer.html = function(html) {\n          return String(html).replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n        };\n        return marked.parse(text, {\n          renderer: renderer,\n          headerIds: false,\n          mangle: false\n        });\n      }\n\n      // Function to load source code into the editor\n      async function loadSourceCode() {\n        try {\n          const response = await fetch('/source');\n          if (response.ok) {\n            const data = await response.json();\n            document.getElementById('sourceCode').value = data.content;\n          }\n        } catch (e) {\n          console.error('Error loading source code:', e);\n        }\n      }\n\n      // Function to update source code from the editor (optional)\n      async function updateSourceCode() {\n        const updatedContent = document.getElementById('sourceCode').value;\n        try {\n          const response = await fetch('/update_source', {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify({ content: updatedContent })\n          });\n          if (response.ok) {\n            console.log('Source code updated successfully.');\n          } else {\n            console.error('Failed to update source code.');\n          }\n        } catch (e) {\n          console.error('Error updating source code:', e);\n        }\n      }\n\n      // Append a message to chatBox; content is rendered as Markdown.\n      function appendMessage(role, content) {\n        const msgDiv = document.createElement('div');\n        msgDiv.className = 'message';\n        msgDiv.innerHTML = '<strong class=\"' + role + '\">' + role + ':</strong><div>' + renderMarkdown(content) + '</div>';\n        chatBox.appendChild(msgDiv);\n      }\n\n      // Append a commit summary to commitSummaries\n      function appendCommitSummary(summary) {\n        const summaryDiv = document.createElement('div');\n        summaryDiv.className = 'commit-summary';\n        summaryDiv.textContent = summary;\n        commitSummaries.appendChild(summaryDiv);\n      }\n\n      // Scroll chatBox to the bottom.\n      function scrollToBottom(element) {\n        element.scrollTop = element.scrollHeight;\n      }\n\n      // Load the existing conversation transcript from the server.\n      async function loadTranscript() {\n        try {\n          const response = await fetch('/transcript');\n          if (response.ok) {\n            const data = await response.json();\n            data.forEach(msg => {\n              appendMessage(msg.role, msg.content);\n              if (msg.role.toLowerCase() === 'assistant') {\n                const commit = extractCommitSummary(msg.content);\n                if (commit) {\n                  appendCommitSummary(commit);\n                }\n              }\n            });\n            scrollToBottom(chatBox);\n            scrollToBottom(commitSummaries);\n          }\n        } catch (e) {\n          console.error('Error loading transcript:', e);\n        }\n      }\n\n      // Function to extract commit summary\n      function extractCommitSummary(content) {\n        const regex = /^Commit Summary:\\s*(.+)/m;\n        const match = content.match(regex);\n        return match ? match[1].trim() : null;\n      }\n\n      // Listen for Ctrl+Enter to submit the form.\n      function setupEventListeners() {\n        const promptInput = document.getElementById(\"promptInput\");\n        const chatForm = document.getElementById(\"chatForm\");\n        const throbber = document.getElementById(\"throbber\");\n        const chatBox = document.getElementById(\"chatBox\");\n        const commitSummaries = document.getElementById(\"commitSummaries\");\n\n        promptInput.addEventListener(\"keydown\", function(e) {\n          if (e.ctrlKey && e.key === \"Enter\") {\n            e.preventDefault();\n            chatForm.dispatchEvent(new Event(\"submit\", {cancelable: true}));\n          }\n        });\n\n        chatForm.addEventListener('submit', async (e) => {\n          e.preventDefault();\n          const prompt = promptInput.value.trim();\n          if (!prompt) return;\n          appendMessage(\"User\", prompt);\n          scrollToBottom(chatBox);\n          promptInput.value = \"\";\n          throbber.style.display = \"block\";\n\n          try {\n            const response = await fetch(\"/chat\", {\n              method: \"POST\",\n              headers: { \"Content-Type\": \"application/json\" },\n              body: JSON.stringify({ prompt: prompt })\n            });\n            if (response.ok) {\n              const data = await response.json();\n              chatBox.innerHTML = \"\";\n              document.getElementById(\"commitSummaries\").innerHTML = \"\";\n              data.forEach(msg => {\n                appendMessage(msg.role, msg.content);\n                if (msg.role.toLowerCase() === 'assistant') {\n                  const commit = extractCommitSummary(msg.content);\n                  if (commit) {\n                    appendCommitSummary(commit);\n                  }\n                }\n              });\n              scrollToBottom(chatBox);\n              scrollToBottom(commitSummaries);\n              // Reload the source code after AI updates\n              await loadSourceCode();\n            } else {\n              console.error(\"Server error:\", response.statusText);\n            }\n          } catch (error) {\n            console.error(\"Fetch error:\", error);\n          }\n          throbber.style.display = \"none\";\n        });\n      }\n\n      // On startup, load the previous conversation (if any) and the source code.\n      window.onload = function() {\n        loadTranscript();\n        loadSourceCode();\n        setupEventListeners();\n      };\n    </script>\n  </head>\n  <body>\n    <div id=\"header\">\n      <h1>Project Manager Chat Interface</h1>\n      <p>Currently working on file: <strong>{{ source_file }}</strong></p>\n    </div>\n    <div id=\"chatBox\">\n      <!-- Existing conversation will be loaded here -->\n    </div>\n    <div id=\"commitSummariesContainer\">\n      <h2>Commit Summaries</h2>\n      <div id=\"commitSummaries\">\n        <!-- Commit summaries will be loaded here -->\n      </div>\n    </div>\n    <div id=\"throbber\"></div>\n    <hr>\n    <form id=\"chatForm\">\n      <textarea id=\"promptInput\" rows=\"5\" cols=\"60\" placeholder=\"Enter your prompt here...\"></textarea><br>\n      <input type=\"submit\" value=\"Submit\">\n    </form>\n\n    <!-- New Section for Source Code Editor -->\n    <div id=\"sourceCodeContainer\">\n      <h2>Source Code Editor</h2>\n      <textarea id=\"sourceCode\" readonly></textarea>\n      <!-- Optional: Add a button to manually update source code if editing is allowed -->\n      <!-- <button onclick=\"updateSourceCode()\">Update Source Code</button> -->\n    </div>\n  </body>\n</html>\n\"\"\"\n\n# In-memory conversation history.\nchat_history = []\n\ndef transcript_filename():\n    \"\"\"Return the transcript filename based on the active file's basename.\"\"\"\n    base, _ = os.path.splitext(SOURCE_FILE)\n    return f\"{base}-transcript.json\"\n\ndef load_transcript_from_disk():\n    \"\"\"Load transcript from disk into chat_history (if it exists).\"\"\"\n    fname = transcript_filename()\n    if os.path.exists(fname):\n        try:\n            with open(fname, \"r\") as f:\n                data = json.load(f)\n                if isinstance(data, list):\n                    return data\n        except Exception:\n            pass\n    return []\n\ndef update_transcript():\n    \"\"\"Write the current chat_history to the transcript file and commit it to git.\"\"\"\n    fname = transcript_filename()\n    with open(fname, \"w\") as f:\n        json.dump(chat_history, f, indent=2)\n    transcript_commit_msg = f\"Update transcript for {os.path.basename(SOURCE_FILE)}\"\n    commit_changes(fname, transcript_commit_msg)\n\ndef extract_commit_summary(text):\n    \"\"\"Search for a line starting with 'Commit Summary:' at the beginning of a line and return its content.\"\"\"\n    match = re.search(r\"^Commit Summary:\\s*(.*)\", text, re.MULTILINE)\n    return match.group(1).strip() if match else \"\"\n\ndef extract_code(text):\n    \"\"\"\n    Extract the contents of the first code block using a simple state machine.\n    The code block is assumed to start with a line that (after stripping whitespace)\n    starts with three backticks and ends when a line that is exactly three backticks is encountered.\n    \"\"\"\n    lines = text.splitlines()\n    in_code_block = False\n    code_lines = []\n    for line in lines:\n        stripped = line.strip()\n        if not in_code_block:\n            if stripped.startswith(\"```\"):\n                in_code_block = True\n            continue\n        else:\n            if stripped == \"```\":\n                break\n            code_lines.append(line)\n    return \"\\n\".join(code_lines).strip()\n\ndef extract_professional_message(text):\n    \"\"\"Extract the professional message before the code block.\"\"\"\n    match = re.match(r\"^(.*?)```\", text, re.DOTALL)\n    return match.group(1).strip() if match else text.strip()\n\ndef compute_diff(old_content, new_content):\n    \"\"\"Compute a unified diff between old_content and new_content.\"\"\"\n    old_lines = old_content.splitlines(keepends=True)\n    new_lines = new_content.splitlines(keepends=True)\n    diff_lines = difflib.unified_diff(old_lines, new_lines, fromfile=\"Before\", tofile=\"After\")\n    return \"\".join(diff_lines)\n\ndef commit_changes(file_path, commit_message):\n    \"\"\"Stage the given file and commit changes to git with the provided commit message.\"\"\"\n    try:\n        subprocess.run([\"git\", \"add\", file_path], check=True)\n        subprocess.run([\"git\", \"commit\", \"-m\", commit_message], check=True)\n        return True\n    except subprocess.CalledProcessError:\n        return False\n\ndef load_coding_contexts(context_names):\n    \"\"\"Load coding contexts from the contexts/ directory based on provided context names.\"\"\"\n    contexts = []\n    for name in context_names:\n        context_path = os.path.join(\"contexts\", f\"{name}.txt\")\n        if os.path.exists(context_path):\n            try:\n                with open(context_path, \"r\") as f:\n                    content = f.read().strip()\n                    if content:\n                        contexts.append(content)\n            except Exception as e:\n                print(f\"Error loading context '{name}': {e}\")\n        else:\n            print(f\"Context file '{context_path}' does not exist.\")\n    return contexts\n\ndef build_prompt_messages(system_prompt, conversation, source_file, model, coding_contexts):\n    \"\"\"\n    Build a list of messages for the API:\n      - Include the coding contexts at the beginning of the system prompt.\n      - Include the system prompt. If the model is \"o1-mini\" (which doesn't support 'system'),\n        include it as a user message prefixed with \"SYSTEM:\".\n      - For each user message, include it verbatim.\n      - For each assistant message, include only the commit summary.\n      - Append a final user message with the current on-disk file contents.\n    \"\"\"\n    messages = []\n    if coding_contexts:\n        combined_context = \"\\n\".join([f\"Context: {ctx}\" for ctx in coding_contexts])\n        system_prompt = f\"{combined_context}\\n\\n{system_prompt}\"\n    if model == \"o1-mini\":\n        messages.append({\"role\": \"user\", \"content\": \"SYSTEM: \" + system_prompt})\n    else:\n        messages.append({\"role\": \"system\", \"content\": system_prompt})\n    for msg in conversation:\n        role = msg[\"role\"].lower()\n        if role == \"assistant\":\n            commit = extract_commit_summary(msg[\"content\"])\n            messages.append({\"role\": role, \"content\": commit})\n        else:\n            messages.append({\"role\": role, \"content\": msg[\"content\"]})\n    try:\n        with open(source_file, \"r\") as f:\n            file_contents = f.read()\n    except Exception:\n        file_contents = \"\"\n    final_msg = {\n        \"role\": \"user\",\n        \"content\": \"The following is the code which has been generated so far:\\n\" + file_contents\n    }\n    messages.append(final_msg)\n    return messages\n\napp = Flask(__name__)\n\n# Route to serve static files from the static/ directory.\n@app.route(\"/static/<path:filename>\")\ndef serve_static(filename):\n    return send_from_directory(\"static\", filename)\n\n# Route to return the current transcript as JSON.\n@app.route(\"/transcript\", methods=[\"GET\"])\ndef get_transcript():\n    return jsonify(chat_history)\n\n# New Route to get the current source code content\n@app.route(\"/source\", methods=[\"GET\"])\ndef get_source():\n    if not os.path.exists(SOURCE_FILE):\n        return jsonify({\"content\": \"\"})\n    try:\n        with open(SOURCE_FILE, \"r\") as f:\n            content = f.read()\n        return jsonify({\"content\": content})\n    except Exception as e:\n        return jsonify({\"error\": str(e)}), 500\n\n# New Route to update the source code (optional)\n@app.route(\"/update_source\", methods=[\"POST\"])\ndef update_source():\n    data = request.get_json()\n    if not data or \"content\" not in data:\n        return jsonify({\"error\": \"No content provided.\"}), 400\n    new_content = data[\"content\"]\n    try:\n        with open(SOURCE_FILE, \"w\") as f:\n            f.write(new_content)\n        commit_msg = \"Manually updated source code via web UI.\"\n        if commit_changes(SOURCE_FILE, commit_msg):\n            return jsonify({\"message\": \"Source code updated successfully.\"})\n        else:\n            return jsonify({\"error\": \"Failed to commit changes to git.\"}), 500\n    except Exception as e:\n        return jsonify({\"error\": str(e)}), 500\n\n# Chat endpoint: accepts a JSON prompt, updates conversation, file, and transcript, then returns the full conversation.\n@app.route(\"/chat\", methods=[\"POST\"])\ndef chat():\n    global chat_history, SOURCE_FILE, DEBUG\n    data = request.get_json()\n    if not data or \"prompt\" not in data:\n        return jsonify({\"error\": \"No prompt provided.\"}), 400\n    user_input = data[\"prompt\"]\n    chat_history.append({\"role\": \"User\", \"content\": user_input})\n\n    if not os.path.exists(SOURCE_FILE) or os.path.getsize(SOURCE_FILE) == 0:\n        system_prompt = (\n            \"You are an assistant managing a software project. When given a prompt, respond with a brief professional message summarizing the changes and any questions or suggestions you have. Then, generate the complete contents for the project file. Output only the code in a single code block (using triple backticks) without additional commentary.\"\n        )\n    else:\n        system_prompt = (\n            \"You are an assistant managing a software project. The project file already has content. When given a prompt for changes, respond with a brief professional message summarizing the changes and any questions or suggestions you have. Then, generate the complete updated file contents. Output only the updated code in a single code block (using triple backticks). \"\n            \"Then, on a new line after the code block, output a commit summary starting with 'Commit Summary:' followed by a brief description of the changes.\"\n        )\n\n    messages = build_prompt_messages(system_prompt, chat_history, SOURCE_FILE, \"o1-mini\", CODING_CONTEXTS)\n\n    if DEBUG:\n        print(\"DEBUG: AI prompt messages:\")\n        print(json.dumps(messages, indent=2))\n\n    try:\n        response = client.chat.completions.create(\n            model=\"o1-mini\",\n            messages=messages,\n            temperature=1\n        )\n    except Exception as e:\n        error_msg = f\"Error calling OpenAI API: {str(e)}\"\n        chat_history.append({\"role\": \"Assistant\", \"content\": error_msg})\n        update_transcript()\n        return jsonify(chat_history), 500\n\n    reply = response.choices[0].message.content\n    professional_message = extract_professional_message(reply)\n    chat_history.append({\"role\": \"Assistant\", \"content\": professional_message})\n\n    new_file_content = extract_code(reply)\n    commit_summary = extract_commit_summary(reply)\n\n    if not os.path.exists(SOURCE_FILE) or os.path.getsize(SOURCE_FILE) == 0:\n        with open(SOURCE_FILE, \"w\") as f:\n            f.write(new_file_content)\n    else:\n        with open(SOURCE_FILE, \"r\") as f:\n            old_content = f.read()\n        diff_text = compute_diff(old_content, new_file_content)\n        if diff_text:\n            with open(SOURCE_FILE, \"w\") as f:\n                f.write(new_file_content)\n            commit_msg = commit_summary if commit_summary else f\"Applied changes: {user_input}\"\n            if not commit_changes(SOURCE_FILE, commit_msg):\n                chat_history.append({\"role\": \"Assistant\", \"content\": \"Error committing changes to git.\"})\n        else:\n            chat_history.append({\"role\": \"Assistant\", \"content\": \"No changes detected.\"})\n\n    update_transcript()\n    return jsonify(chat_history)\n\n# Main page: serves the HTML page with the active file indicator.\n@app.route(\"/\", methods=[\"GET\"])\ndef index():\n    return render_template_string(HTML_TEMPLATE, source_file=SOURCE_FILE)\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser(description=\"Manage a software project via the OpenAI API.\")\n    parser.add_argument(\"source_file\", help=\"Path to the project file to manage.\")\n    parser.add_argument(\"--port\", type=int, default=5000, help=\"Port on which the server will run (default: 5000)\")\n    parser.add_argument(\"--debug\", action=\"store_true\", help=\"Print full AI prompt on each API call for debugging.\")\n    parser.add_argument(\"--contexts\", nargs='*', default=[], help=\"List of coding contexts to apply.\")\n    args = parser.parse_args()\n\n    SOURCE_FILE = args.source_file\n    DEBUG = args.debug\n    if not os.path.exists(SOURCE_FILE):\n        open(SOURCE_FILE, \"w\").close()\n    chat_history = load_transcript_from_disk()\n    CODING_CONTEXTS = load_coding_contexts(args.contexts)\n\n    app.run(port=args.port)\n```\n\nCommit Summary: Removed code blocks and commit summaries from chatbox messages, ensuring only professional summaries are displayed. Code and commit information are now managed in separate UI sections."
  },
  {
    "role": "User",
    "content": "Make sure we strip the code blocks from the chatbox messages on initial load as well"
  },
  {
    "role": "Assistant",
    "content": "Updated the `loadTranscript` function to strip code blocks from chatbox messages during the initial load. Now, only the professional messages without code blocks and commit summaries are displayed in the chatbox, ensuring a cleaner user interface."
  },
  {
    "role": "User",
    "content": "Print a simple list of active coding contexts at the top of our web interface, right after the \"currently working on file:\" section"
  },
  {
    "role": "Assistant",
    "content": "Added a section to display the list of active coding contexts in the web interface, showing them after the \"Currently working on file:\" section."
  },
  {
    "role": "User",
    "content": "Don't print the full contents of the coding context, just a list of names of active contexts. Maybe we can display the full text on hover or in an infobox on click?"
  },
  {
    "role": "Assistant",
    "content": "I've updated the code to display only the names of active coding contexts in the web interface. The full content of each context is now available as a tooltip when hovering over the context name. This enhances the user interface by keeping it clean while still providing access to detailed context information when needed."
  },
  {
    "role": "User",
    "content": "The coding contexts are being displayed twice now"
  },
  {
    "role": "Assistant",
    "content": "Noted the issue with coding contexts being displayed twice. Removed the server-side rendering of coding contexts from the HTML template to rely solely on the client-side JavaScript for displaying active coding contexts."
  },
  {
    "role": "User",
    "content": "We need to handle the case when codingContexts is not present, as this currently throws errors when a response comes back from the server when not using a specific coding context"
  },
  {
    "role": "Assistant",
    "content": "I have updated the project to gracefully handle cases where `CODING_CONTEXTS` is not present. This includes adding necessary checks in both the backend and frontend to prevent errors when no coding contexts are specified. Additionally, I addressed the issue of coding contexts being displayed twice by ensuring they are loaded and appended only once."
  },
  {
    "role": "User",
    "content": "Let's tidy up the UI a bit. We'll want to make a three-column layout. On the left we'll have a project browser - for now it's just a placeholder. The middle column will hold the source code editor at the top, which will be the primary UI element - it will flex resize both horizontally and vertically. Below the source code editor, we'll have the chat log and chat input. The commit summary will go in the right column.\n\nAlso, make it dark mode."
  },
  {
    "role": "Assistant",
    "content": "Added a three-column layout to the web UI with a project browser placeholder on the left, a resizable source code editor and chat section in the center, and commit summaries on the right. Implemented dark mode for the interface to enhance user experience."
  },
  {
    "role": "User",
    "content": "Give the chat transcript a reasonable max-height, so that the code view can take up the majority of the space. We don't want to have scroll bars on the main body, we want our UI to fill the screen horizontally and vertically, and be responsive to resizing."
  },
  {
    "role": "Assistant",
    "content": "Added a reasonable max-height to the chat transcript to ensure the source code editor occupies the majority of the space. Adjusted the flex layout to make the UI fully responsive without scroll bars on the main body. Ensured that the three-column layout adapts smoothly to different screen sizes."
  },
  {
    "role": "User",
    "content": "The chat window can be about half its current height. Also, hide the submit button."
  },
  {
    "role": "Assistant",
    "content": "Updated the chat window to have a reduced height and hid the submit button to streamline the user interface."
  },
  {
    "role": "User",
    "content": "Remove the flex parameter from the chatContainer element"
  },
  {
    "role": "Assistant",
    "content": "Removed the `flex` parameter from the `#chatContainer` element to resolve layout issues and prevent unintended resizing behavior. Please review the changes to ensure the chat container displays as expected."
  },
  {
    "role": "User",
    "content": "Move the active coding contexts display up to the top of the second column, in the space next to where it says \"source code editor\". Change them to be a simple inline list of small badges."
  },
  {
    "role": "Assistant",
    "content": "Moved the active coding contexts display into the main content area and styled them as inline badges to prevent duplication and enhance the UI."
  },
  {
    "role": "User",
    "content": "We don't need a label for \"active coding contexts\" - nothing but a simple list of small badges along the top, floating to the right of the section label"
  },
  {
    "role": "Assistant",
    "content": "I've reviewed the provided code and ensured that code blocks are properly stripped from the chatbox messages on initial load. The `extract_commit_summary` function's regex now correctly matches lines starting with \"Commit Summary:\" at the beginning of a line, preventing self-matching issues. Additionally, I addressed the duplication of coding contexts and handled cases where `codingContexts` might not be present to avoid runtime errors."
  },
  {
    "role": "User",
    "content": "Don't send the full back-and-forth conversation with each request. We'll just send the system prompt, any active coding contexts, the most recent user request, and the code printout."
  },
  {
    "role": "Assistant",
    "content": "Updated the prompt construction to include only the system prompt, active coding contexts, the most recent user request, and the code printout. This change ensures that the full conversation history is no longer sent with each request, streamlining the interaction with the AI."
  },
  {
    "role": "User",
    "content": "\ufffc(index):298 Error loading transcript or coding contexts: ReferenceError: codingContexts is not defined\n    at loadTranscript (\ufffc(index):289:13)"
  },
  {
    "role": "Assistant",
    "content": "I've fixed the JavaScript error by correctly referencing the `activeCodingContexts` DOM element instead of the undefined `codingContexts`. This ensures that the coding contexts are properly loaded and manipulated."
  },
  {
    "role": "User",
    "content": "Populate the project browser with the directory structure of the active directory"
  },
  {
    "role": "Assistant",
    "content": "I've updated the project to populate the Project Browser with the directory structure of the active directory. A new server-side route retrieves the directory structure, and the front-end dynamically fetches and displays it."
  },
  {
    "role": "User",
    "content": "Let's add tabs at the top of the source code editor, and allow for multiple open files. Selecting a file from the project browser will open a tab with that file's contents and update the chat history with the history for that file, if a transcript for that file exists."
  },
  {
    "role": "Assistant",
    "content": "To accommodate multiple open files with a tabbed interface in the source code editor, the following updates have been made:\n\n1. **Frontend Enhancements**:\n   - Added a tab bar above the source code editor to manage multiple open files.\n   - Implemented JavaScript functions to handle opening, switching, and closing tabs.\n   - Updated the project browser to open files in new tabs and load corresponding chat histories.\n\n2. **Backend Modifications**:\n   - Updated the transcript management to handle multiple files by maintaining a separate chat history for each file.\n   - Adjusted routes and helper functions to support operations on multiple files.\n\nThese changes enhance the application's usability by allowing users to work on multiple files simultaneously and view their respective histories seamlessly."
  },
  {
    "role": "User",
    "content": "When selecting a file from the project browser, make sure we send the full path so we can open files in subdirectories"
  },
  {
    "role": "Assistant",
    "content": "Implemented the functionality to send the full path when selecting a file from the project browser, enabling the opening of files in subdirectories."
  },
  {
    "role": "User",
    "content": "Clicking the tabs at the top should set that tab as the active file"
  },
  {
    "role": "Assistant",
    "content": "I have implemented the functionality to set a tab as the active file when it is clicked. Now, clicking on any existing tab will activate it, load the corresponding source code, chat history, and commit summaries accordingly. This ensures a seamless user experience when navigating between multiple open files."
  },
  {
    "role": "User",
    "content": "Let's modify the code editor window to use the CodeMirror library (loaded from a CDN), and make the code editable. Pressing ctrl+s should save the active file to disk with the changes."
  },
  {
    "role": "Assistant",
    "content": "The code editor window has been updated to use the CodeMirror library, making the code editable. Pressing `Ctrl+S` will now save the active file to disk with the changes."
  }
]