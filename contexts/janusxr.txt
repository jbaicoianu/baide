You are working on a web-based 3d world using the JanusXR library. A janus room is made with JML markup embedded in an HTML file, like so:

```
<html>
  <body>
    <script src="https://web.janusxr.org/1.5.53/janusweb.js"></script>
    <janus-viewer>
      <assets>
        <assetimage id="myimage" src="https://my.server.com/image.jpg" />
        <assetobject id="my3dobject" src="https://other.server.net/thingy.glb" />
        <assetsound id="ambientsound" src="mysound.ogg" />
        <assetsound id="localizedsound" src="crickets.mp3" />
        <assetvideo id="coolvideo" src="/path/to/coolvideo.mp4" />
        <assetscript src="myscript.js" />
      </assets>
      <room pos="0 0 0">
        <object id="my3dobject" js_id="unique_object_id" col="red" pos="1 2 3" />
        <object id="cube" image_id="myimage" pos="7 -8 9" scale="100 .1 100" />
        <object id="sphere" pos="0 0 -4" collision_id="sphere" onclick="alert('hello!')" />
        <image id="myimage" pos="10 0 1" rotation="0 45 0" />
        <sound id="ambientsound" />
        <sound id="localizedsound" pos="-4 0 3.2" />
        <video pos="0 0 -10" scale="16 9 1" id="coolvideo" />
      </room>
    </janus-viewer>
  </body>
</html>
```

Janus markup can also be extended with custom elements in assetscripts by using the following syntax:
```
room.registerElement('my-custom-element', {
  someattribute: 'defaultvalue',
  numericattribute: 4.2,
  booleanattribute: true,
  vectorattribute: V(),

  create() {
    // Called once for each instance of this element to perform any initialization, including creating child objects and setting up events
    this.thing1 = this.createObject('object', { id: 'cube', scale: V(1, .1, 2), col: 'yellow' });
    this.thing2 = this.createObject('object', { id: 'torus', col: '#0f0', collision_id: 'torus' });

    this.thing2.addEventListener('click', ev => this.handleClick(ev));
    this.thing2.addEventListener('mouseover', ev => this.handleMouseOver(ev));
    this.thing2.addEventListener('mouseout', ev => this.handleMouseOut(ev));
  },
  update(dt) {
    // Called once per frame for each instance of this element
    this.thing1.rotation.y += Math.PI/2 * dt;
  },
  handleClick(ev) {
    this.thing1.col = '#f0f';
  },
  handleMouseOver(ev) {
    this.thing2.scale.set(1.1, 1.1, 1.1);
  },
  handleMouseOut(ev) {
    this.thing2.scale.set(1, 1, 1);
  }
});
```

Note that `this.createObject()` creates objects as a child of this object (which will follow the object as it moves and rotates), while `room.createObject()` can be used to create objects parented to the room (useful for spawning objects like projectiles or objects that our custom element places in the world).

Attributes are defined simply by specifying them in our element definition as member attributes of our custom element, which can then be referenced in markup and in code. Their type is inferred by specifying a default value (boolean, string, numeric, or vector)

After defining a custom element, it can be used as needed within a <room> using `<my-custom-element someattribute="boing" />`, or spawned using `this.createObject('my-custom-element', { someattribute: "boing" })`

Note:
- units are in meters
- rotations are always in degrees, not radians
- built-in primitive types are sphere, cube, cone, cylinder, pyramid, torus, pipe, and plane
- All types of elements support a number of default attributes: pos, rotation, scale, vel, mass, accel, restitution, opacity, visible, billboard, classname, renderorder, pickable, collidable, collision_id, rotate_deg_per_sec, rotate_axis, locked, js_id)
- All types of elements support a number of member functions: createObject, appendChild, removeChild, addEventListener, dispatchEvent, removeEventListener, localToWorld, worldToLocal, distanceTo, addForce, removeForce, die, addClass, removeClass, hasClass, raycast, getElementsByTagName
- All types of elements support a number of events: update, change, collision, mouseover, mouseout, mousemove, mousedown, mouseup, click, touchstart, touchmove, touchend, dragover, drag, dragenter, dragleave, dragstart, dragend, drop. These events can be handled in code using the `object.addEventListener('eventtype', handlerFunction)` syntax or in markup with `<object oneventtype="doSomethingWith(this, event)">`
- vector attributes like pos, vel, etc. are instances of THREE.Vector3(). Special handlers allow you to assign strings of the form "x y z", arrays [x, y, z], or other vectors, and reading these properties always returns an instance of THREE.Vector3. Vector3 objects can be allocated with the V() convenience function, which optionally takes x,y,z arguments.
- colors can be specified using standard HTML color names, hex codes (short or long), or RGB values with values from 0..1
- Our createObject() functions take two parameters. The first is the object type, which can be either one of the built-ins (object, image, video, text, paragraph, link, light, particle, sound) or any of our defined custom elements.  The second parameter is an object containing any attributes we want to specify.
- object, image, video, and sound elements accept an "id" parameter which specifies the id of the corresponding asset definition. For object elements, this can also be one of the built-in primitives specified above.
- the physics engine can handle projectile physics (pos, vel, and accel properties) and angular rotations (rotation, angular, angularacceleration). It also supports force generators, eg, `this.addForce('friction', 0.2)` `this.addForce('static', V(0, 10, 0))`. It also has built-in collision handling between all objects with specified collision_id attributes.
